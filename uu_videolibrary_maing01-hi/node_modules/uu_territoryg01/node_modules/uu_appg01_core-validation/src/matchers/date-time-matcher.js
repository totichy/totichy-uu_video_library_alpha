"use strict";

const Matcher = require("../matcher");
const ValidationResult = require("../validation-result");
const Validator = require("../validator");
const d3 = require("d3-time-format");

const DEFAULT_FORMAT = "%Y-%m-%dT%H:%M:%S.%L%Z";
const DEFAULT_FORMAT_NO_MILLIS = "%Y-%m-%dT%H:%M:%S%Z";

class _Datetime extends Matcher {
  constructor(...params) {
    super("datetime");
    this.params = params;
    this._validate(params[0], params[1], params[2]);
  }

  match(value, ctx, ...args) {
    this.result = new ValidationResult();

    if (value == undefined) {
      return this;
    }

    let parsed = this.timeParse(value);
    if (!parsed && this.format === DEFAULT_FORMAT) {
      let timeParseNoMillis = d3.timeParse(DEFAULT_FORMAT_NO_MILLIS);
      parsed = timeParseNoMillis(value);
    }
    if ((this._isString(value) && parsed) || value.constructor.name === "Date") {
      parsed = parsed || value; // when date instance is provided
      if (!isNaN(parsed)) { /// can happen when date instance is provided
        if (this.fromParsed && parsed < this.fromParsed) {
          this.result.addInvalidValueError("datetime.e002", `The value must not be before ${this.from}.`);
        }
        if (this.toParsed && parsed >= this.toParsed) {
          this.result.addInvalidValueError("datetime.e003", `The value must not be ${this.to} and later.`);
        }
      } else {
        this.result.addInvalidTypeError("datetime.e001", `The value must be datetime in ${this.format} datetime format.`);
      }
    } else {
      this.result.addInvalidTypeError("datetime.e001", `The value must be datetime in ${this.format} datetime format.`);
    }

    return this;
  }

  _isString(value) {
    return typeof value === "string" || !value instanceof String;
  }

  _validate(format, from, to) {
    if (format && !this._isString(format)) {
      throw new TypeError(`datetime matcher: "${format}" has to be a String`);
    }
    let parsed;
    format = format || DEFAULT_FORMAT;
    let timeParse = d3.timeParse(format);
    this.timeParse = timeParse;
    this.format = format;
    if (from) {
      if (!this._isString(from)) {
        throw new TypeError(`datetime matcher: "${from}" has to be a String`);
      }
      parsed = timeParse(from);
      if (!parsed) {
        if (this.format === DEFAULT_FORMAT) {
          let timeParseNoMillis = d3.timeParse(DEFAULT_FORMAT_NO_MILLIS);
          parsed = timeParseNoMillis(from);
        }
        if (!parsed) {
          throw new Error(`datetime matcher: "${from}" does not match "${format}"`);
        }
      }
      this.from = from;
      this.fromParsed = parsed;
    }
    if (to) {
      if (!this._isString(to)) {
        throw new TypeError(`datetime matcher: "${to}" has to be a String`);
      }
      parsed = timeParse(to);
      if (!parsed) {
        if (this.format === DEFAULT_FORMAT) {
          let timeParseNoMillis = d3.timeParse(DEFAULT_FORMAT_NO_MILLIS);
          parsed = timeParseNoMillis(to);
        }
        if (!parsed) {
          throw new Error(`datetime matcher: "${to}" does not match "${format}"`);
        }
      }
      this.to = to;
      this.toParsed = parsed;
    }
  }
}

function Datetime(...params) {
  let matcher = new _Datetime(...params);
  if (this && this.matchers && this.matchers[0]) {
    this.matchers.push(matcher);
    return this;
  } else {
    let validator = new Validator(null);
    validator._loadMatchers();
    validator.matchers = [matcher];
    return validator;
  }
}

module.exports = Datetime;
