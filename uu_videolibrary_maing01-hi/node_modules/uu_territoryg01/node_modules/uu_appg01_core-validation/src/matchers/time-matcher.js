"use strict";

const Matcher = require("../matcher");
const ValidationResult = require("../validation-result");
const Validator = require("../validator");
const d3 = require("d3-time-format");

const DEFAULT_FORMAT = "%H:%M";

class _Time extends Matcher {
  constructor(...params) {
    super("time");
    this.params = params;
    this._validate(params[0], params[1], params[2]);
  }

  match(value, ctx, ...args) {
    this.result = new ValidationResult();

    if (value == undefined) {
      return this;
    }

    let parsed = this.timeParse(value);
    if (this._isString(value) && parsed) {
      if (this.fromParsed && parsed < this.fromParsed) {
        this.result.addInvalidValueError("time.e002", `The value must not be before ${this.from}.`);
      }
      if (this.toParsed && parsed >= this.toParsed) {
        this.result.addInvalidValueError("time.e003", `The value must not be ${this.to} and later.`);
      }
    } else {
      this.result.addInvalidTypeError("time.e001", `The value must be time in ${this.format} time format .`);
    }

    return this;
  }

  _isString(value) {
    return typeof value === "string" || !value instanceof String;
  }

  _validate(format, from, to) {
    if (format && !this._isString(format)) {
      throw new TypeError(`time matcher: "${format}" has to be a String`);
    }
    let parsed;
    format = format || DEFAULT_FORMAT;
    let timeParse = d3.timeParse(format);
    this.timeParse = timeParse;
    this.format = format;
    if (from) {
      if (!this._isString(from)) {
        throw new TypeError(`time matcher: "${from}" has to be a String`);
      }
      parsed = timeParse(from);
      if (!parsed) {
        throw new Error(`time matcher: "${from}" does not match "${format}"`);
      }
      this.from = from;
      this.fromParsed = parsed;
    }
    if (to) {
      if (!this._isString(to)) {
        throw new TypeError(`time matcher: "${to}" has to be a String`);
      }
      parsed = timeParse(to);
      if (!parsed) {
        throw new Error(`time matcher: "${to}" does not match "${format}"`);
      }
      this.to = to;
      this.toParsed = parsed;
    }
  }
}

function Time(...params) {
  let matcher = new _Time(...params);
  if (this && this.matchers && this.matchers[0]) {
    this.matchers.push(matcher);
    return this;
  } else {
    let validator = new Validator(null);
    validator._loadMatchers();
    validator.matchers = [matcher];
    return validator;
  }
}

module.exports = Time;
