"use strict";

const Matcher = require("../matcher");
const ValidationResult = require("../validation-result");
const Validator = require("../validator");
const Sizeof = require("object-sizeof");

class _shape extends Matcher {
  constructor(...params) {
    super("shape");
    this.params = params;
  }

  match(value, ctx, validator = undefined, noStrict = undefined, maxSize = undefined) {
    ctx = { ...ctx };
    this.result = new ValidationResult();

    if (value == undefined) {
      return this;
    }

    if (!noStrict && typeof this.params[1] === "boolean") {
      noStrict = this.params[1];
    }

    if (!maxSize && typeof this.params[2] === "number") {
      maxSize = this.params[2];
    }

    if (typeof value !== "object") {
      this.result.addInvalidTypeError("shape.e001", "The value must be shape.");
    } else {
      if (typeof validator === "number") {
        [validator, noStrict, maxSize] = [undefined, undefined, validator];
      }
      if (typeof validator === "boolean") {
        [validator, noStrict, maxSize] = [undefined, validator, noStrict];
      }

      if (validator) {
        ctx["parentValue"] = value;

        let keys = Object.keys(validator);
        for (let i = 0; i < keys.length; i += 1) {
          let key = keys[i];
          let vld = validator[key];
          let val = value[key] === undefined ? undefined : value[key];

          let index = 0;
          vld.matchers.forEach(matcher => {
            let childResult;
            if (matcher.params && matcher.params[index]) {
              childResult = matcher.match(val, ctx, matcher.params[index]);
            } else if (matcher) {
              childResult = matcher.match(val, ctx, undefined);
            }
            if (childResult.result) {
              childResult = childResult.result;
            }
            if (childResult.valid && childResult.unsuportedKeys.length === 0) {
              //continue;
            }
            this.result.addChildResult(key, childResult);
            index += 1;
          });
        }
        if (!this.result.valid) {
          this.result.addInvalidValueError("shape.e002", "The content of shape must be valid.");
        }
        Object.keys(value).forEach(key => {
          if (!key.match(/^[^\.]+$/)) {
            let invalidKey = new ValidationResult();
            invalidKey.addInvalidKeyError("shape.e004", "The key must not contain dot.");
            this.result.addChildResult(key, invalidKey);
          }
          if (!noStrict && !(key in validator)) {
            this.result.addUnsupportedKey(key);
          }
        });
      }
      if (maxSize && Sizeof(value) > maxSize) {
        this.result.addInvalidValueError("shape.e003", `The size of the shape must not exceed ${maxSize} B.`);
      }
    }
    return this;
  }
}

let shape = function(...params) {
  let matcher = new _shape(...params);
  if (this && this.matchers && this.matchers[0]) {
    this.matchers.push(matcher);
    return this;
  } else {
    let validator = new Validator(null);
    validator._loadMatchers();
    validator.matchers = [matcher];
    return validator;
  }
};

module.exports = shape;
