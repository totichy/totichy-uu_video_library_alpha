/*!
 * UAF Licence for the uu5CodeKit software.
 * 
 * Copyright (c) 2016-present, Unicorn a.s.
 * All rights reserved.
 * 
 * Definitions
 * -----------
 * This licence agreement is based on the original "BSD Licence" published by
 * the Regents of the University of California in 1990.
 * 
 * The term "Software" means the uu5 package, its modules, components,
 * all program files, source code, examples, media, and documentation which are part
 * of the Software package, as well as any portion of them. The term "Author" means
 * Unicorn a.s. and all its subsidiaries and/or affiliates.
 * 
 * Licence Agreement
 * -----------------
 * 
 * Redistribution and use of this Software in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 
 * 3. All derivative products containing user interface must display the following
 *    acknowledgement in the appropriate "About window" or website section accessible
 *    by all users of the product:
 * 
 *      This product includes following software developed by
 *      <a href="https://unicorn.com">Unicorn a.s.</a>:
 *      <a href="https://uuos9.plus4u.net/uu-bookkitg01-main/78462435-86b4d5a4a030400784764ebdb972bbda/book">UAF</a>,
 *      <a href="https://uuos9.plus4u.net/uu-bookkitg01-main/78462435-ed11ec379073476db0aa295ad6c00178/book">uu5</a>.
 * 
 * 4. All derivative products must not block the default uu5 browser console message containing
 *    Software version information and copyright notice of the Author.
 * 
 * 5. The use of any portion of this Software is not allowed in the products
 *    that fully or partially resemble the functionality of the Software
 *    or otherwise compete with the Software unless they are licenced under the same licence
 *    conditions and provided free of charge. Specific prior written permission is required otherwise.
 * 
 * 6. Neither the name of the Author nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 * 
 * Disclaimer
 * ----------
 * THIS SOFTWARE IS PROVIDED BY AUTHOR "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(1);


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(2);

/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _codekit_ace_mode_uu5_worker_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var _codekit_ace_mode_uu5_worker_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_codekit_ace_mode_uu5_worker_js__WEBPACK_IMPORTED_MODULE_0__);


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"no use strict"; // ace 1.2.8 worker-xml.js with changes:
// 1. Annotated using NOTE marker.
// 2. Changed module names containing "xml" into "uu5".
// 3. Replaced window.onerror and window.onmessage by self.onerror & self.onmessage.

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

(function (window) {
  if (typeof window.window != "undefined" && window.document) return;
  if (window.require && window.define) return;

  if (!window.console) {
    window.console = function () {
      var msgs = Array.prototype.slice.call(arguments, 0);
      postMessage({
        type: "log",
        data: msgs
      });
    };

    window.console.error = window.console.warn = window.console.log = window.console.trace = window.console;
  }

  window.window = window;
  window.ace = window;

  self.onerror = function (message, file, line, col, err) {
    // NOTE Changed from window.onerror to self.onerror.
    postMessage({
      type: "error",
      data: {
        message: message,
        data: err.data,
        file: file,
        line: line,
        col: col,
        stack: err.stack
      }
    });
  };

  window.normalizeModule = function (parentId, moduleName) {
    // normalize plugin requires
    if (moduleName.indexOf("!") !== -1) {
      var chunks = moduleName.split("!");
      return window.normalizeModule(parentId, chunks[0]) + "!" + window.normalizeModule(parentId, chunks[1]);
    } // normalize relative requires


    if (moduleName.charAt(0) == ".") {
      var base = parentId.split("/").slice(0, -1).join("/");
      moduleName = (base ? base + "/" : "") + moduleName;

      while (moduleName.indexOf(".") !== -1 && previous != moduleName) {
        var previous = moduleName;
        moduleName = moduleName.replace(/^\.\//, "").replace(/\/\.\//, "/").replace(/[^\/]+\/\.\.\//, "");
      }
    }

    return moduleName;
  };

  window.require = function require(parentId, id) {
    if (!id) {
      id = parentId;
      parentId = null;
    }

    if (!id.charAt) throw new Error("worker.js require() accepts only (parentId, id) as arguments");
    id = window.normalizeModule(parentId, id);
    var module = window.require.modules[id];

    if (module) {
      if (!module.initialized) {
        module.initialized = true;
        module.exports = module.factory().exports;
      }

      return module.exports;
    }

    if (!window.require.tlns) return console.log("unable to load " + id);
    var path = resolveModuleId(id, window.require.tlns);
    if (path.slice(-3) != ".js") path += ".js";
    window.require.id = id;
    window.require.modules[id] = {}; // prevent infinite loop on broken modules

    importScripts(path);
    return window.require(parentId, id);
  };

  function resolveModuleId(id, paths) {
    var testPath = id,
        tail = "";

    while (testPath) {
      var alias = paths[testPath];

      if (typeof alias == "string") {
        return alias + tail;
      } else if (alias) {
        return alias.location.replace(/\/*$/, "/") + (tail || alias.main || alias.name);
      } else if (alias === false) {
        return "";
      }

      var i = testPath.lastIndexOf("/");
      if (i === -1) break;
      tail = testPath.substr(i) + tail;
      testPath = testPath.slice(0, i);
    }

    return id;
  }

  window.require.modules = {};
  window.require.tlns = {};

  window.define = function (id, deps, _factory) {
    if (arguments.length == 2) {
      _factory = deps;

      if (typeof id != "string") {
        deps = id;
        id = window.require.id;
      }
    } else if (arguments.length == 1) {
      _factory = id;
      deps = [];
      id = window.require.id;
    }

    if (typeof _factory != "function") {
      window.require.modules[id] = {
        exports: _factory,
        initialized: true
      };
      return;
    }

    if (!deps.length) // If there is no dependencies, we inject "require", "exports" and
      // "module" as dependencies, to provide CommonJS compatibility.
      deps = ["require", "exports", "module"];

    var req = function req(childId) {
      return window.require(id, childId);
    };

    window.require.modules[id] = {
      exports: {},
      factory: function factory() {
        var module = this;

        var returnExports = _factory.apply(this, deps.map(function (dep) {
          switch (dep) {
            // Because "require", "exports" and "module" aren't actual
            // dependencies, we must handle them seperately.
            case "require":
              return req;

            case "exports":
              return module.exports;

            case "module":
              return module;
            // But for all other dependencies, we can just go ahead and
            // require them.

            default:
              return req(dep);
          }
        }));

        if (returnExports) module.exports = returnExports;
        return module;
      }
    };
  };

  window.define.amd = {};
  window.require.tlns = {}; // NOTE Used window.require.

  window.initBaseUrls = function initBaseUrls(topLevelNamespaces) {
    for (var i in topLevelNamespaces) {
      window.require.tlns[i] = topLevelNamespaces[i];
    } // NOTE Used window.require.

  };

  window.initSender = function initSender() {
    var EventEmitter = window.require("ace/lib/event_emitter").EventEmitter;

    var oop = window.require("ace/lib/oop");

    var Sender = function Sender() {};

    (function () {
      oop.implement(this, EventEmitter);

      this.callback = function (data, callbackId) {
        postMessage({
          type: "call",
          id: callbackId,
          data: data
        });
      };

      this.emit = function (name, data) {
        postMessage({
          type: "event",
          name: name,
          data: data
        });
      };
    }).call(Sender.prototype);
    return new Sender();
  };

  var main = window.main = null;
  var sender = window.sender = null;

  self.onmessage = function (e) {
    // NOTE Changed from window.onmessage to self.onmessage.
    var msg = e.data;

    if (msg.event && sender) {
      sender._signal(msg.event, msg.data);
    } else if (msg.command) {
      if (main[msg.command]) main[msg.command].apply(main, msg.args);else if (window[msg.command]) window[msg.command].apply(window, msg.args);else throw new Error("Unknown command:" + msg.command);
    } else if (msg.init) {
      window.initBaseUrls(msg.tlns);

      window.require("ace/lib/es5-shim"); // NOTE Used window.require.


      sender = window.sender = window.initSender();

      var clazz = window.require(msg.module)[msg.classname]; // NOTE Used window.require.


      main = window.main = new clazz(sender);
    }
  };
})(this);

var ace = this.ace; // NOTE Added local variable.

self.ace = ace; // NOTE Added to be available in other files (mode-uu5-worker/*).

ace.define("ace/lib/oop", ["require", "exports", "module"], function (require, exports, module) {
  "use strict";

  exports.inherits = function (ctor, superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };

  exports.mixin = function (obj, mixin) {
    for (var key in mixin) {
      obj[key] = mixin[key];
    }

    return obj;
  };

  exports.implement = function (proto, mixin) {
    exports.mixin(proto, mixin);
  };
});
ace.define("ace/lib/lang", ["require", "exports", "module"], function (require, exports, module) {
  "use strict";

  exports.last = function (a) {
    return a[a.length - 1];
  };

  exports.stringReverse = function (string) {
    return string.split("").reverse().join("");
  };

  exports.stringRepeat = function (string, count) {
    var result = "";

    while (count > 0) {
      if (count & 1) result += string;
      if (count >>= 1) string += string;
    }

    return result;
  };

  var trimBeginRegexp = /^\s\s*/;
  var trimEndRegexp = /\s\s*$/;

  exports.stringTrimLeft = function (string) {
    return string.replace(trimBeginRegexp, "");
  };

  exports.stringTrimRight = function (string) {
    return string.replace(trimEndRegexp, "");
  };

  exports.copyObject = function (obj) {
    var copy = {};

    for (var key in obj) {
      copy[key] = obj[key];
    }

    return copy;
  };

  exports.copyArray = function (array) {
    var copy = [];

    for (var i = 0, l = array.length; i < l; i++) {
      if (array[i] && _typeof(array[i]) == "object") copy[i] = this.copyObject(array[i]);else copy[i] = array[i];
    }

    return copy;
  };

  exports.deepCopy = function deepCopy(obj) {
    if (_typeof(obj) !== "object" || !obj) return obj;
    var copy;

    if (Array.isArray(obj)) {
      copy = [];

      for (var key = 0; key < obj.length; key++) {
        copy[key] = deepCopy(obj[key]);
      }

      return copy;
    }

    if (Object.prototype.toString.call(obj) !== "[object Object]") return obj;
    copy = {};

    for (var key in obj) {
      copy[key] = deepCopy(obj[key]);
    }

    return copy;
  };

  exports.arrayToMap = function (arr) {
    var map = {};

    for (var i = 0; i < arr.length; i++) {
      map[arr[i]] = 1;
    }

    return map;
  };

  exports.createMap = function (props) {
    var map = Object.create(null);

    for (var i in props) {
      map[i] = props[i];
    }

    return map;
  };

  exports.arrayRemove = function (array, value) {
    for (var i = 0; i <= array.length; i++) {
      if (value === array[i]) {
        array.splice(i, 1);
      }
    }
  };

  exports.escapeRegExp = function (str) {
    return str.replace(/([.*+?^${}()|[\]\/\\])/g, "\\$1");
  };

  exports.escapeHTML = function (str) {
    return str.replace(/&/g, "&#38;").replace(/"/g, "&#34;").replace(/'/g, "&#39;").replace(/</g, "&#60;");
  };

  exports.getMatchOffsets = function (string, regExp) {
    var matches = [];
    string.replace(regExp, function (str) {
      matches.push({
        offset: arguments[arguments.length - 2],
        length: str.length
      });
    });
    return matches;
  };

  exports.deferredCall = function (fcn) {
    var timer = null;

    var callback = function callback() {
      timer = null;
      fcn();
    };

    var deferred = function deferred(timeout) {
      deferred.cancel();
      timer = setTimeout(callback, timeout || 0);
      return deferred;
    };

    deferred.schedule = deferred;

    deferred.call = function () {
      this.cancel();
      fcn();
      return deferred;
    };

    deferred.cancel = function () {
      clearTimeout(timer);
      timer = null;
      return deferred;
    };

    deferred.isPending = function () {
      return timer;
    };

    return deferred;
  };

  exports.delayedCall = function (fcn, defaultTimeout) {
    var timer = null;

    var callback = function callback() {
      timer = null;
      fcn();
    };

    var _self = function _self(timeout) {
      if (timer == null) timer = setTimeout(callback, timeout || defaultTimeout);
    };

    _self.delay = function (timeout) {
      timer && clearTimeout(timer);
      timer = setTimeout(callback, timeout || defaultTimeout);
    };

    _self.schedule = _self;

    _self.call = function () {
      this.cancel();
      fcn();
    };

    _self.cancel = function () {
      timer && clearTimeout(timer);
      timer = null;
    };

    _self.isPending = function () {
      return timer;
    };

    return _self;
  };
});
ace.define("ace/range", ["require", "exports", "module"], function (require, exports, module) {
  "use strict";

  var comparePoints = function comparePoints(p1, p2) {
    return p1.row - p2.row || p1.column - p2.column;
  };

  var Range = function Range(startRow, startColumn, endRow, endColumn) {
    this.start = {
      row: startRow,
      column: startColumn
    };
    this.end = {
      row: endRow,
      column: endColumn
    };
  };

  (function () {
    this.isEqual = function (range) {
      return this.start.row === range.start.row && this.end.row === range.end.row && this.start.column === range.start.column && this.end.column === range.end.column;
    };

    this.toString = function () {
      return "Range: [" + this.start.row + "/" + this.start.column + "] -> [" + this.end.row + "/" + this.end.column + "]";
    };

    this.contains = function (row, column) {
      return this.compare(row, column) == 0;
    };

    this.compareRange = function (range) {
      var cmp,
          end = range.end,
          start = range.start;
      cmp = this.compare(end.row, end.column);

      if (cmp == 1) {
        cmp = this.compare(start.row, start.column);

        if (cmp == 1) {
          return 2;
        } else if (cmp == 0) {
          return 1;
        } else {
          return 0;
        }
      } else if (cmp == -1) {
        return -2;
      } else {
        cmp = this.compare(start.row, start.column);

        if (cmp == -1) {
          return -1;
        } else if (cmp == 1) {
          return 42;
        } else {
          return 0;
        }
      }
    };

    this.comparePoint = function (p) {
      return this.compare(p.row, p.column);
    };

    this.containsRange = function (range) {
      return this.comparePoint(range.start) == 0 && this.comparePoint(range.end) == 0;
    };

    this.intersects = function (range) {
      var cmp = this.compareRange(range);
      return cmp == -1 || cmp == 0 || cmp == 1;
    };

    this.isEnd = function (row, column) {
      return this.end.row == row && this.end.column == column;
    };

    this.isStart = function (row, column) {
      return this.start.row == row && this.start.column == column;
    };

    this.setStart = function (row, column) {
      if (_typeof(row) == "object") {
        this.start.column = row.column;
        this.start.row = row.row;
      } else {
        this.start.row = row;
        this.start.column = column;
      }
    };

    this.setEnd = function (row, column) {
      if (_typeof(row) == "object") {
        this.end.column = row.column;
        this.end.row = row.row;
      } else {
        this.end.row = row;
        this.end.column = column;
      }
    };

    this.inside = function (row, column) {
      if (this.compare(row, column) == 0) {
        if (this.isEnd(row, column) || this.isStart(row, column)) {
          return false;
        } else {
          return true;
        }
      }

      return false;
    };

    this.insideStart = function (row, column) {
      if (this.compare(row, column) == 0) {
        if (this.isEnd(row, column)) {
          return false;
        } else {
          return true;
        }
      }

      return false;
    };

    this.insideEnd = function (row, column) {
      if (this.compare(row, column) == 0) {
        if (this.isStart(row, column)) {
          return false;
        } else {
          return true;
        }
      }

      return false;
    };

    this.compare = function (row, column) {
      if (!this.isMultiLine()) {
        if (row === this.start.row) {
          return column < this.start.column ? -1 : column > this.end.column ? 1 : 0;
        }
      }

      if (row < this.start.row) return -1;
      if (row > this.end.row) return 1;
      if (this.start.row === row) return column >= this.start.column ? 0 : -1;
      if (this.end.row === row) return column <= this.end.column ? 0 : 1;
      return 0;
    };

    this.compareStart = function (row, column) {
      if (this.start.row == row && this.start.column == column) {
        return -1;
      } else {
        return this.compare(row, column);
      }
    };

    this.compareEnd = function (row, column) {
      if (this.end.row == row && this.end.column == column) {
        return 1;
      } else {
        return this.compare(row, column);
      }
    };

    this.compareInside = function (row, column) {
      if (this.end.row == row && this.end.column == column) {
        return 1;
      } else if (this.start.row == row && this.start.column == column) {
        return -1;
      } else {
        return this.compare(row, column);
      }
    };

    this.clipRows = function (firstRow, lastRow) {
      if (this.end.row > lastRow) var end = {
        row: lastRow + 1,
        column: 0
      };else if (this.end.row < firstRow) var end = {
        row: firstRow,
        column: 0
      };
      if (this.start.row > lastRow) var start = {
        row: lastRow + 1,
        column: 0
      };else if (this.start.row < firstRow) var start = {
        row: firstRow,
        column: 0
      };
      return Range.fromPoints(start || this.start, end || this.end);
    };

    this.extend = function (row, column) {
      var cmp = this.compare(row, column);
      if (cmp == 0) return this;else if (cmp == -1) var start = {
        row: row,
        column: column
      };else var end = {
        row: row,
        column: column
      };
      return Range.fromPoints(start || this.start, end || this.end);
    };

    this.isEmpty = function () {
      return this.start.row === this.end.row && this.start.column === this.end.column;
    };

    this.isMultiLine = function () {
      return this.start.row !== this.end.row;
    };

    this.clone = function () {
      return Range.fromPoints(this.start, this.end);
    };

    this.collapseRows = function () {
      if (this.end.column == 0) return new Range(this.start.row, 0, Math.max(this.start.row, this.end.row - 1), 0);else return new Range(this.start.row, 0, this.end.row, 0);
    };

    this.toScreenRange = function (session) {
      var screenPosStart = session.documentToScreenPosition(this.start);
      var screenPosEnd = session.documentToScreenPosition(this.end);
      return new Range(screenPosStart.row, screenPosStart.column, screenPosEnd.row, screenPosEnd.column);
    };

    this.moveBy = function (row, column) {
      this.start.row += row;
      this.start.column += column;
      this.end.row += row;
      this.end.column += column;
    };
  }).call(Range.prototype);

  Range.fromPoints = function (start, end) {
    return new Range(start.row, start.column, end.row, end.column);
  };

  Range.comparePoints = comparePoints;

  Range.comparePoints = function (p1, p2) {
    return p1.row - p2.row || p1.column - p2.column;
  };

  exports.Range = Range;
});
ace.define("ace/apply_delta", ["require", "exports", "module"], function (require, exports, module) {
  "use strict";

  function throwDeltaError(delta, errorText) {
    console.log("Invalid Delta:", delta);
    throw "Invalid Delta: " + errorText;
  }

  function positionInDocument(docLines, position) {
    return position.row >= 0 && position.row < docLines.length && position.column >= 0 && position.column <= docLines[position.row].length;
  }

  function validateDelta(docLines, delta) {
    if (delta.action != "insert" && delta.action != "remove") throwDeltaError(delta, "delta.action must be 'insert' or 'remove'");
    if (!(delta.lines instanceof Array)) throwDeltaError(delta, "delta.lines must be an Array");
    if (!delta.start || !delta.end) throwDeltaError(delta, "delta.start/end must be an present");
    var start = delta.start;
    if (!positionInDocument(docLines, delta.start)) throwDeltaError(delta, "delta.start must be contained in document");
    var end = delta.end;
    if (delta.action == "remove" && !positionInDocument(docLines, end)) throwDeltaError(delta, "delta.end must contained in document for 'remove' actions");
    var numRangeRows = end.row - start.row;
    var numRangeLastLineChars = end.column - (numRangeRows == 0 ? start.column : 0);
    if (numRangeRows != delta.lines.length - 1 || delta.lines[numRangeRows].length != numRangeLastLineChars) throwDeltaError(delta, "delta.range must match delta lines");
  }

  exports.applyDelta = function (docLines, delta, doNotValidate) {
    var row = delta.start.row;
    var startColumn = delta.start.column;
    var line = docLines[row] || "";

    switch (delta.action) {
      case "insert":
        var lines = delta.lines;

        if (lines.length === 1) {
          docLines[row] = line.substring(0, startColumn) + delta.lines[0] + line.substring(startColumn);
        } else {
          var args = [row, 1].concat(delta.lines);
          docLines.splice.apply(docLines, args);
          docLines[row] = line.substring(0, startColumn) + docLines[row];
          docLines[row + delta.lines.length - 1] += line.substring(startColumn);
        }

        break;

      case "remove":
        var endColumn = delta.end.column;
        var endRow = delta.end.row;

        if (row === endRow) {
          docLines[row] = line.substring(0, startColumn) + line.substring(endColumn);
        } else {
          docLines.splice(row, endRow - row + 1, line.substring(0, startColumn) + docLines[endRow].substring(endColumn));
        }

        break;
    }
  };
});
ace.define("ace/lib/event_emitter", ["require", "exports", "module"], function (require, exports, module) {
  "use strict";

  var EventEmitter = {};

  var stopPropagation = function stopPropagation() {
    this.propagationStopped = true;
  };

  var preventDefault = function preventDefault() {
    this.defaultPrevented = true;
  };

  EventEmitter._emit = EventEmitter._dispatchEvent = function (eventName, e) {
    this._eventRegistry || (this._eventRegistry = {});
    this._defaultHandlers || (this._defaultHandlers = {});
    var listeners = this._eventRegistry[eventName] || [];
    var defaultHandler = this._defaultHandlers[eventName];
    if (!listeners.length && !defaultHandler) return;
    if (_typeof(e) != "object" || !e) e = {};
    if (!e.type) e.type = eventName;
    if (!e.stopPropagation) e.stopPropagation = stopPropagation;
    if (!e.preventDefault) e.preventDefault = preventDefault;
    listeners = listeners.slice();

    for (var i = 0; i < listeners.length; i++) {
      listeners[i](e, this);
      if (e.propagationStopped) break;
    }

    if (defaultHandler && !e.defaultPrevented) return defaultHandler(e, this);
  };

  EventEmitter._signal = function (eventName, e) {
    var listeners = (this._eventRegistry || {})[eventName];
    if (!listeners) return;
    listeners = listeners.slice();

    for (var i = 0; i < listeners.length; i++) {
      listeners[i](e, this);
    }
  };

  EventEmitter.once = function (eventName, callback) {
    var _self = this;

    callback && this.addEventListener(eventName, function newCallback() {
      _self.removeEventListener(eventName, newCallback);

      callback.apply(null, arguments);
    });
  };

  EventEmitter.setDefaultHandler = function (eventName, callback) {
    var handlers = this._defaultHandlers;
    if (!handlers) handlers = this._defaultHandlers = {
      _disabled_: {}
    };

    if (handlers[eventName]) {
      var old = handlers[eventName];
      var disabled = handlers._disabled_[eventName];
      if (!disabled) handlers._disabled_[eventName] = disabled = [];
      disabled.push(old);
      var i = disabled.indexOf(callback);
      if (i != -1) disabled.splice(i, 1);
    }

    handlers[eventName] = callback;
  };

  EventEmitter.removeDefaultHandler = function (eventName, callback) {
    var handlers = this._defaultHandlers;
    if (!handlers) return;
    var disabled = handlers._disabled_[eventName];

    if (handlers[eventName] == callback) {
      var old = handlers[eventName];
      if (disabled) this.setDefaultHandler(eventName, disabled.pop());
    } else if (disabled) {
      var i = disabled.indexOf(callback);
      if (i != -1) disabled.splice(i, 1);
    }
  };

  EventEmitter.on = EventEmitter.addEventListener = function (eventName, callback, capturing) {
    this._eventRegistry = this._eventRegistry || {};
    var listeners = this._eventRegistry[eventName];
    if (!listeners) listeners = this._eventRegistry[eventName] = [];
    if (listeners.indexOf(callback) == -1) listeners[capturing ? "unshift" : "push"](callback);
    return callback;
  };

  EventEmitter.off = EventEmitter.removeListener = EventEmitter.removeEventListener = function (eventName, callback) {
    this._eventRegistry = this._eventRegistry || {};
    var listeners = this._eventRegistry[eventName];
    if (!listeners) return;
    var index = listeners.indexOf(callback);
    if (index !== -1) listeners.splice(index, 1);
  };

  EventEmitter.removeAllListeners = function (eventName) {
    if (this._eventRegistry) this._eventRegistry[eventName] = [];
  };

  exports.EventEmitter = EventEmitter;
});
ace.define("ace/anchor", ["require", "exports", "module", "ace/lib/oop", "ace/lib/event_emitter"], function (require, exports, module) {
  "use strict";

  var oop = require("./lib/oop");

  var EventEmitter = require("./lib/event_emitter").EventEmitter;

  var Anchor = exports.Anchor = function (doc, row, column) {
    this.$onChange = this.onChange.bind(this);
    this.attach(doc);
    if (typeof column == "undefined") this.setPosition(row.row, row.column);else this.setPosition(row, column);
  };

  (function () {
    oop.implement(this, EventEmitter);

    this.getPosition = function () {
      return this.$clipPositionToDocument(this.row, this.column);
    };

    this.getDocument = function () {
      return this.document;
    };

    this.$insertRight = false;

    this.onChange = function (delta) {
      if (delta.start.row == delta.end.row && delta.start.row != this.row) return;
      if (delta.start.row > this.row) return;
      var point = $getTransformedPoint(delta, {
        row: this.row,
        column: this.column
      }, this.$insertRight);
      this.setPosition(point.row, point.column, true);
    };

    function $pointsInOrder(point1, point2, equalPointsInOrder) {
      var bColIsAfter = equalPointsInOrder ? point1.column <= point2.column : point1.column < point2.column;
      return point1.row < point2.row || point1.row == point2.row && bColIsAfter;
    }

    function $getTransformedPoint(delta, point, moveIfEqual) {
      var deltaIsInsert = delta.action == "insert";
      var deltaRowShift = (deltaIsInsert ? 1 : -1) * (delta.end.row - delta.start.row);
      var deltaColShift = (deltaIsInsert ? 1 : -1) * (delta.end.column - delta.start.column);
      var deltaStart = delta.start;
      var deltaEnd = deltaIsInsert ? deltaStart : delta.end; // Collapse insert range.

      if ($pointsInOrder(point, deltaStart, moveIfEqual)) {
        return {
          row: point.row,
          column: point.column
        };
      }

      if ($pointsInOrder(deltaEnd, point, !moveIfEqual)) {
        return {
          row: point.row + deltaRowShift,
          column: point.column + (point.row == deltaEnd.row ? deltaColShift : 0)
        };
      }

      return {
        row: deltaStart.row,
        column: deltaStart.column
      };
    }

    this.setPosition = function (row, column, noClip) {
      var pos;

      if (noClip) {
        pos = {
          row: row,
          column: column
        };
      } else {
        pos = this.$clipPositionToDocument(row, column);
      }

      if (this.row == pos.row && this.column == pos.column) return;
      var old = {
        row: this.row,
        column: this.column
      };
      this.row = pos.row;
      this.column = pos.column;

      this._signal("change", {
        old: old,
        value: pos
      });
    };

    this.detach = function () {
      this.document.removeEventListener("change", this.$onChange);
    };

    this.attach = function (doc) {
      this.document = doc || this.document;
      this.document.on("change", this.$onChange);
    };

    this.$clipPositionToDocument = function (row, column) {
      var pos = {};

      if (row >= this.document.getLength()) {
        pos.row = Math.max(0, this.document.getLength() - 1);
        pos.column = this.document.getLine(pos.row).length;
      } else if (row < 0) {
        pos.row = 0;
        pos.column = 0;
      } else {
        pos.row = row;
        pos.column = Math.min(this.document.getLine(pos.row).length, Math.max(0, column));
      }

      if (column < 0) pos.column = 0;
      return pos;
    };
  }).call(Anchor.prototype);
});
ace.define("ace/document", ["require", "exports", "module", "ace/lib/oop", "ace/apply_delta", "ace/lib/event_emitter", "ace/range", "ace/anchor"], function (require, exports, module) {
  "use strict";

  var oop = require("./lib/oop");

  var applyDelta = require("./apply_delta").applyDelta;

  var EventEmitter = require("./lib/event_emitter").EventEmitter;

  var Range = require("./range").Range;

  var Anchor = require("./anchor").Anchor;

  var Document = function Document(textOrLines) {
    this.$lines = [""];

    if (textOrLines.length === 0) {
      this.$lines = [""];
    } else if (Array.isArray(textOrLines)) {
      this.insertMergedLines({
        row: 0,
        column: 0
      }, textOrLines);
    } else {
      this.insert({
        row: 0,
        column: 0
      }, textOrLines);
    }
  };

  (function () {
    oop.implement(this, EventEmitter);

    this.setValue = function (text) {
      var len = this.getLength() - 1;
      this.remove(new Range(0, 0, len, this.getLine(len).length));
      this.insert({
        row: 0,
        column: 0
      }, text);
    };

    this.getValue = function () {
      return this.getAllLines().join(this.getNewLineCharacter());
    };

    this.createAnchor = function (row, column) {
      return new Anchor(this, row, column);
    };

    if ("aaa".split(/a/).length === 0) {
      this.$split = function (text) {
        return text.replace(/\r\n|\r/g, "\n").split("\n");
      };
    } else {
      this.$split = function (text) {
        return text.split(/\r\n|\r|\n/);
      };
    }

    this.$detectNewLine = function (text) {
      var match = text.match(/^.*?(\r\n|\r|\n)/m);
      this.$autoNewLine = match ? match[1] : "\n";

      this._signal("changeNewLineMode");
    };

    this.getNewLineCharacter = function () {
      switch (this.$newLineMode) {
        case "windows":
          return "\r\n";

        case "unix":
          return "\n";

        default:
          return this.$autoNewLine || "\n";
      }
    };

    this.$autoNewLine = "";
    this.$newLineMode = "auto";

    this.setNewLineMode = function (newLineMode) {
      if (this.$newLineMode === newLineMode) return;
      this.$newLineMode = newLineMode;

      this._signal("changeNewLineMode");
    };

    this.getNewLineMode = function () {
      return this.$newLineMode;
    };

    this.isNewLine = function (text) {
      return text == "\r\n" || text == "\r" || text == "\n";
    };

    this.getLine = function (row) {
      return this.$lines[row] || "";
    };

    this.getLines = function (firstRow, lastRow) {
      return this.$lines.slice(firstRow, lastRow + 1);
    };

    this.getAllLines = function () {
      return this.getLines(0, this.getLength());
    };

    this.getLength = function () {
      return this.$lines.length;
    };

    this.getTextRange = function (range) {
      return this.getLinesForRange(range).join(this.getNewLineCharacter());
    };

    this.getLinesForRange = function (range) {
      var lines;

      if (range.start.row === range.end.row) {
        lines = [this.getLine(range.start.row).substring(range.start.column, range.end.column)];
      } else {
        lines = this.getLines(range.start.row, range.end.row);
        lines[0] = (lines[0] || "").substring(range.start.column);
        var l = lines.length - 1;
        if (range.end.row - range.start.row == l) lines[l] = lines[l].substring(0, range.end.column);
      }

      return lines;
    };

    this.insertLines = function (row, lines) {
      console.warn("Use of document.insertLines is deprecated. Use the insertFullLines method instead.");
      return this.insertFullLines(row, lines);
    };

    this.removeLines = function (firstRow, lastRow) {
      console.warn("Use of document.removeLines is deprecated. Use the removeFullLines method instead.");
      return this.removeFullLines(firstRow, lastRow);
    };

    this.insertNewLine = function (position) {
      console.warn("Use of document.insertNewLine is deprecated. Use insertMergedLines(position, ['', '']) instead.");
      return this.insertMergedLines(position, ["", ""]);
    };

    this.insert = function (position, text) {
      if (this.getLength() <= 1) this.$detectNewLine(text);
      return this.insertMergedLines(position, this.$split(text));
    };

    this.insertInLine = function (position, text) {
      var start = this.clippedPos(position.row, position.column);
      var end = this.pos(position.row, position.column + text.length);
      this.applyDelta({
        start: start,
        end: end,
        action: "insert",
        lines: [text]
      }, true);
      return this.clonePos(end);
    };

    this.clippedPos = function (row, column) {
      var length = this.getLength();

      if (row === undefined) {
        row = length;
      } else if (row < 0) {
        row = 0;
      } else if (row >= length) {
        row = length - 1;
        column = undefined;
      }

      var line = this.getLine(row);
      if (column == undefined) column = line.length;
      column = Math.min(Math.max(column, 0), line.length);
      return {
        row: row,
        column: column
      };
    };

    this.clonePos = function (pos) {
      return {
        row: pos.row,
        column: pos.column
      };
    };

    this.pos = function (row, column) {
      return {
        row: row,
        column: column
      };
    };

    this.$clipPosition = function (position) {
      var length = this.getLength();

      if (position.row >= length) {
        position.row = Math.max(0, length - 1);
        position.column = this.getLine(length - 1).length;
      } else {
        position.row = Math.max(0, position.row);
        position.column = Math.min(Math.max(position.column, 0), this.getLine(position.row).length);
      }

      return position;
    };

    this.insertFullLines = function (row, lines) {
      row = Math.min(Math.max(row, 0), this.getLength());
      var column = 0;

      if (row < this.getLength()) {
        lines = lines.concat([""]);
        column = 0;
      } else {
        lines = [""].concat(lines);
        row--;
        column = this.$lines[row].length;
      }

      this.insertMergedLines({
        row: row,
        column: column
      }, lines);
    };

    this.insertMergedLines = function (position, lines) {
      var start = this.clippedPos(position.row, position.column);
      var end = {
        row: start.row + lines.length - 1,
        column: (lines.length == 1 ? start.column : 0) + lines[lines.length - 1].length
      };
      this.applyDelta({
        start: start,
        end: end,
        action: "insert",
        lines: lines
      });
      return this.clonePos(end);
    };

    this.remove = function (range) {
      var start = this.clippedPos(range.start.row, range.start.column);
      var end = this.clippedPos(range.end.row, range.end.column);
      this.applyDelta({
        start: start,
        end: end,
        action: "remove",
        lines: this.getLinesForRange({
          start: start,
          end: end
        })
      });
      return this.clonePos(start);
    };

    this.removeInLine = function (row, startColumn, endColumn) {
      var start = this.clippedPos(row, startColumn);
      var end = this.clippedPos(row, endColumn);
      this.applyDelta({
        start: start,
        end: end,
        action: "remove",
        lines: this.getLinesForRange({
          start: start,
          end: end
        })
      }, true);
      return this.clonePos(start);
    };

    this.removeFullLines = function (firstRow, lastRow) {
      firstRow = Math.min(Math.max(0, firstRow), this.getLength() - 1);
      lastRow = Math.min(Math.max(0, lastRow), this.getLength() - 1);
      var deleteFirstNewLine = lastRow == this.getLength() - 1 && firstRow > 0;
      var deleteLastNewLine = lastRow < this.getLength() - 1;
      var startRow = deleteFirstNewLine ? firstRow - 1 : firstRow;
      var startCol = deleteFirstNewLine ? this.getLine(startRow).length : 0;
      var endRow = deleteLastNewLine ? lastRow + 1 : lastRow;
      var endCol = deleteLastNewLine ? 0 : this.getLine(endRow).length;
      var range = new Range(startRow, startCol, endRow, endCol);
      var deletedLines = this.$lines.slice(firstRow, lastRow + 1);
      this.applyDelta({
        start: range.start,
        end: range.end,
        action: "remove",
        lines: this.getLinesForRange(range)
      });
      return deletedLines;
    };

    this.removeNewLine = function (row) {
      if (row < this.getLength() - 1 && row >= 0) {
        this.applyDelta({
          start: this.pos(row, this.getLine(row).length),
          end: this.pos(row + 1, 0),
          action: "remove",
          lines: ["", ""]
        });
      }
    };

    this.replace = function (range, text) {
      if (!(range instanceof Range)) range = Range.fromPoints(range.start, range.end);
      if (text.length === 0 && range.isEmpty()) return range.start;
      if (text == this.getTextRange(range)) return range.end;
      this.remove(range);
      var end;

      if (text) {
        end = this.insert(range.start, text);
      } else {
        end = range.start;
      }

      return end;
    };

    this.applyDeltas = function (deltas) {
      for (var i = 0; i < deltas.length; i++) {
        this.applyDelta(deltas[i]);
      }
    };

    this.revertDeltas = function (deltas) {
      for (var i = deltas.length - 1; i >= 0; i--) {
        this.revertDelta(deltas[i]);
      }
    };

    this.applyDelta = function (delta, doNotValidate) {
      var isInsert = delta.action == "insert";

      if (isInsert ? delta.lines.length <= 1 && !delta.lines[0] : !Range.comparePoints(delta.start, delta.end)) {
        return;
      }

      if (isInsert && delta.lines.length > 20000) this.$splitAndapplyLargeDelta(delta, 20000);
      applyDelta(this.$lines, delta, doNotValidate);

      this._signal("change", delta);
    };

    this.$splitAndapplyLargeDelta = function (delta, MAX) {
      var lines = delta.lines;
      var l = lines.length;
      var row = delta.start.row;
      var column = delta.start.column;
      var from = 0,
          to = 0;

      do {
        from = to;
        to += MAX - 1;
        var chunk = lines.slice(from, to);

        if (to > l) {
          delta.lines = chunk;
          delta.start.row = row + from;
          delta.start.column = column;
          break;
        }

        chunk.push("");
        this.applyDelta({
          start: this.pos(row + from, column),
          end: this.pos(row + to, column = 0),
          action: delta.action,
          lines: chunk
        }, true);
      } while (true);
    };

    this.revertDelta = function (delta) {
      this.applyDelta({
        start: this.clonePos(delta.start),
        end: this.clonePos(delta.end),
        action: delta.action == "insert" ? "remove" : "insert",
        lines: delta.lines.slice()
      });
    };

    this.indexToPosition = function (index, startRow) {
      var lines = this.$lines || this.getAllLines();
      var newlineLength = this.getNewLineCharacter().length;

      for (var i = startRow || 0, l = lines.length; i < l; i++) {
        index -= lines[i].length + newlineLength;
        if (index < 0) return {
          row: i,
          column: index + lines[i].length + newlineLength
        };
      }

      return {
        row: l - 1,
        column: lines[l - 1].length
      };
    };

    this.positionToIndex = function (pos, startRow) {
      var lines = this.$lines || this.getAllLines();
      var newlineLength = this.getNewLineCharacter().length;
      var index = 0;
      var row = Math.min(pos.row, lines.length);

      for (var i = startRow || 0; i < row; ++i) {
        index += lines[i].length + newlineLength;
      }

      return index + pos.column;
    };
  }).call(Document.prototype);
  exports.Document = Document;
});
ace.define("ace/worker/mirror", ["require", "exports", "module", "ace/range", "ace/document", "ace/lib/lang"], function (require, exports, module) {
  "use strict";

  var Range = require("../range").Range;

  var Document = require("../document").Document;

  var lang = require("../lib/lang");

  var Mirror = exports.Mirror = function (sender) {
    this.sender = sender;
    var doc = this.doc = new Document("");
    var deferredUpdate = this.deferredUpdate = lang.delayedCall(this.onUpdate.bind(this));

    var _self = this;

    sender.on("change", function (e) {
      var data = e.data;

      if (data[0].start) {
        doc.applyDeltas(data);
      } else {
        for (var i = 0; i < data.length; i += 2) {
          if (Array.isArray(data[i + 1])) {
            var d = {
              action: "insert",
              start: data[i],
              lines: data[i + 1]
            };
          } else {
            var d = {
              action: "remove",
              start: data[i],
              end: data[i + 1]
            };
          }

          doc.applyDelta(d, true);
        }
      }

      if (_self.$timeout) return deferredUpdate.schedule(_self.$timeout);

      _self.onUpdate();
    });
  };

  (function () {
    this.$timeout = 500;

    this.setTimeout = function (timeout) {
      this.$timeout = timeout;
    };

    this.setValue = function (value) {
      this.doc.setValue(value);
      this.deferredUpdate.schedule(this.$timeout);
    };

    this.getValue = function (callbackId) {
      this.sender.callback(this.doc.getValue(), callbackId);
    };

    this.onUpdate = function () {};

    this.isPending = function () {
      return this.deferredUpdate.isPending();
    };
  }).call(Mirror.prototype);
}); // NOTE Extracted ace/worker/sax to separate file (and modified to do uu5string parsing instead of XML parsing).

__webpack_require__(4);

ace.define("ace/mode/uu5/dom", ["require", "exports", "module"], function (require, exports, module) {
  function copy(src, dest) {
    for (var p in src) {
      dest[p] = src[p];
    }
  }

  function _extends(Class, Super) {
    var pt = Class.prototype;

    if (Object.create) {
      var ppt = Object.create(Super.prototype);
      pt.__proto__ = ppt;
    }

    if (!(pt instanceof Super)) {
      function t() {}

      t.prototype = Super.prototype;
      t = new t();
      copy(pt, t);
      Class.prototype = pt = t;
    }

    if (pt.constructor != Class) {
      if (typeof Class != "function") {
        console.error("unknow Class:" + Class);
      }

      pt.constructor = Class;
    }
  }

  var htmlns = "http://www.w3.org/1999/xhtml";
  var NodeType = {};
  var ELEMENT_NODE = NodeType.ELEMENT_NODE = 1;
  var ATTRIBUTE_NODE = NodeType.ATTRIBUTE_NODE = 2;
  var TEXT_NODE = NodeType.TEXT_NODE = 3;
  var CDATA_SECTION_NODE = NodeType.CDATA_SECTION_NODE = 4;
  var ENTITY_REFERENCE_NODE = NodeType.ENTITY_REFERENCE_NODE = 5;
  var ENTITY_NODE = NodeType.ENTITY_NODE = 6;
  var PROCESSING_INSTRUCTION_NODE = NodeType.PROCESSING_INSTRUCTION_NODE = 7;
  var COMMENT_NODE = NodeType.COMMENT_NODE = 8;
  var DOCUMENT_NODE = NodeType.DOCUMENT_NODE = 9;
  var DOCUMENT_TYPE_NODE = NodeType.DOCUMENT_TYPE_NODE = 10;
  var DOCUMENT_FRAGMENT_NODE = NodeType.DOCUMENT_FRAGMENT_NODE = 11;
  var NOTATION_NODE = NodeType.NOTATION_NODE = 12;
  var ExceptionCode = {};
  var ExceptionMessage = {};
  var INDEX_SIZE_ERR = ExceptionCode.INDEX_SIZE_ERR = (ExceptionMessage[1] = "Index size error", 1);
  var DOMSTRING_SIZE_ERR = ExceptionCode.DOMSTRING_SIZE_ERR = (ExceptionMessage[2] = "DOMString size error", 2);
  var HIERARCHY_REQUEST_ERR = ExceptionCode.HIERARCHY_REQUEST_ERR = (ExceptionMessage[3] = "Hierarchy request error", 3);
  var WRONG_DOCUMENT_ERR = ExceptionCode.WRONG_DOCUMENT_ERR = (ExceptionMessage[4] = "Wrong document", 4);
  var INVALID_CHARACTER_ERR = ExceptionCode.INVALID_CHARACTER_ERR = (ExceptionMessage[5] = "Invalid character", 5);
  var NO_DATA_ALLOWED_ERR = ExceptionCode.NO_DATA_ALLOWED_ERR = (ExceptionMessage[6] = "No data allowed", 6);
  var NO_MODIFICATION_ALLOWED_ERR = ExceptionCode.NO_MODIFICATION_ALLOWED_ERR = (ExceptionMessage[7] = "No modification allowed", 7);
  var NOT_FOUND_ERR = ExceptionCode.NOT_FOUND_ERR = (ExceptionMessage[8] = "Not found", 8);
  var NOT_SUPPORTED_ERR = ExceptionCode.NOT_SUPPORTED_ERR = (ExceptionMessage[9] = "Not supported", 9);
  var INUSE_ATTRIBUTE_ERR = ExceptionCode.INUSE_ATTRIBUTE_ERR = (ExceptionMessage[10] = "Attribute in use", 10);
  var INVALID_STATE_ERR = ExceptionCode.INVALID_STATE_ERR = (ExceptionMessage[11] = "Invalid state", 11);
  var SYNTAX_ERR = ExceptionCode.SYNTAX_ERR = (ExceptionMessage[12] = "Syntax error", 12);
  var INVALID_MODIFICATION_ERR = ExceptionCode.INVALID_MODIFICATION_ERR = (ExceptionMessage[13] = "Invalid modification", 13);
  var NAMESPACE_ERR = ExceptionCode.NAMESPACE_ERR = (ExceptionMessage[14] = "Invalid namespace", 14);
  var INVALID_ACCESS_ERR = ExceptionCode.INVALID_ACCESS_ERR = (ExceptionMessage[15] = "Invalid access", 15);

  function DOMException(code, message) {
    if (message instanceof Error) {
      var error = message;
    } else {
      error = this;
      Error.call(this, ExceptionMessage[code]);
      this.message = ExceptionMessage[code];
      if (Error.captureStackTrace) Error.captureStackTrace(this, DOMException);
    }

    error.code = code;
    if (message) this.message = this.message + ": " + message;
    return error;
  }

  DOMException.prototype = Error.prototype;
  copy(ExceptionCode, DOMException);

  function NodeList() {}

  NodeList.prototype = {
    length: 0,
    item: function item(index) {
      return this[index] || null;
    }
  };

  function LiveNodeList(node, refresh) {
    this._node = node;
    this._refresh = refresh;

    _updateLiveList(this);
  }

  function _updateLiveList(list) {
    var inc = list._node._inc || list._node.ownerDocument._inc;

    if (list._inc != inc) {
      var ls = list._refresh(list._node);

      __set__(list, "length", ls.length);

      copy(ls, list);
      list._inc = inc;
    }
  }

  LiveNodeList.prototype.item = function (i) {
    _updateLiveList(this);

    return this[i];
  };

  _extends(LiveNodeList, NodeList);

  function NamedNodeMap() {}

  function _findNodeIndex(list, node) {
    var i = list.length;

    while (i--) {
      if (list[i] === node) {
        return i;
      }
    }
  }

  function _addNamedNode(el, list, newAttr, oldAttr) {
    if (oldAttr) {
      list[_findNodeIndex(list, oldAttr)] = newAttr;
    } else {
      list[list.length++] = newAttr;
    }

    if (el) {
      newAttr.ownerElement = el;
      var doc = el.ownerDocument;

      if (doc) {
        oldAttr && _onRemoveAttribute(doc, el, oldAttr);

        _onAddAttribute(doc, el, newAttr);
      }
    }
  }

  function _removeNamedNode(el, list, attr) {
    var i = _findNodeIndex(list, attr);

    if (i >= 0) {
      var lastIndex = list.length - 1;

      while (i < lastIndex) {
        list[i] = list[++i];
      }

      list.length = lastIndex;

      if (el) {
        var doc = el.ownerDocument;

        if (doc) {
          _onRemoveAttribute(doc, el, attr);

          attr.ownerElement = null;
        }
      }
    } else {
      throw DOMException(NOT_FOUND_ERR, new Error());
    }
  }

  NamedNodeMap.prototype = {
    length: 0,
    item: NodeList.prototype.item,
    getNamedItem: function getNamedItem(key) {
      var i = this.length;

      while (i--) {
        var attr = this[i];

        if (attr.nodeName == key) {
          return attr;
        }
      }
    },
    setNamedItem: function setNamedItem(attr) {
      var el = attr.ownerElement;

      if (el && el != this._ownerElement) {
        throw new DOMException(INUSE_ATTRIBUTE_ERR);
      }

      var oldAttr = this.getNamedItem(attr.nodeName);

      _addNamedNode(this._ownerElement, this, attr, oldAttr);

      return oldAttr;
    },
    setNamedItemNS: function setNamedItemNS(attr) {
      // raises: WRONG_DOCUMENT_ERR,NO_MODIFICATION_ALLOWED_ERR,INUSE_ATTRIBUTE_ERR
      var el = attr.ownerElement,
          oldAttr;

      if (el && el != this._ownerElement) {
        throw new DOMException(INUSE_ATTRIBUTE_ERR);
      }

      oldAttr = this.getNamedItemNS(attr.namespaceURI, attr.localName);

      _addNamedNode(this._ownerElement, this, attr, oldAttr);

      return oldAttr;
    },
    removeNamedItem: function removeNamedItem(key) {
      var attr = this.getNamedItem(key);

      _removeNamedNode(this._ownerElement, this, attr);

      return attr;
    },
    // raises: NOT_FOUND_ERR,NO_MODIFICATION_ALLOWED_ERR
    removeNamedItemNS: function removeNamedItemNS(namespaceURI, localName) {
      var attr = this.getNamedItemNS(namespaceURI, localName);

      _removeNamedNode(this._ownerElement, this, attr);

      return attr;
    },
    getNamedItemNS: function getNamedItemNS(namespaceURI, localName) {
      var i = this.length;

      while (i--) {
        var node = this[i];

        if (node.localName == localName && node.namespaceURI == namespaceURI) {
          return node;
        }
      }

      return null;
    }
  };

  function DOMImplementation(
  /* Object */
  features) {
    this._features = {};

    if (features) {
      for (var feature in features) {
        this._features = features[feature];
      }
    }
  }

  DOMImplementation.prototype = {
    hasFeature: function hasFeature(
    /* string */
    feature,
    /* string */
    version) {
      var versions = this._features[feature.toLowerCase()];

      if (versions && (!version || version in versions)) {
        return true;
      } else {
        return false;
      }
    },
    createDocument: function createDocument(namespaceURI, qualifiedName, doctype) {
      // raises:INVALID_CHARACTER_ERR,NAMESPACE_ERR,WRONG_DOCUMENT_ERR
      var doc = new Document();
      doc.implementation = this;
      doc.childNodes = new NodeList();
      doc.doctype = doctype;

      if (doctype) {
        doc.appendChild(doctype);
      }

      if (qualifiedName) {
        var root = doc.createElementNS(namespaceURI, qualifiedName);
        doc.appendChild(root);
      }

      return doc;
    },
    createDocumentType: function createDocumentType(qualifiedName, publicId, systemId) {
      // raises:INVALID_CHARACTER_ERR,NAMESPACE_ERR
      var node = new DocumentType();
      node.name = qualifiedName;
      node.nodeName = qualifiedName;
      node.publicId = publicId;
      node.systemId = systemId;
      return node;
    }
  };

  function Node() {}

  Node.prototype = {
    firstChild: null,
    lastChild: null,
    previousSibling: null,
    nextSibling: null,
    attributes: null,
    parentNode: null,
    childNodes: null,
    ownerDocument: null,
    nodeValue: null,
    namespaceURI: null,
    prefix: null,
    localName: null,
    insertBefore: function insertBefore(newChild, refChild) {
      //raises
      return _insertBefore(this, newChild, refChild);
    },
    replaceChild: function replaceChild(newChild, oldChild) {
      //raises
      this.insertBefore(newChild, oldChild);

      if (oldChild) {
        this.removeChild(oldChild);
      }
    },
    removeChild: function removeChild(oldChild) {
      return _removeChild(this, oldChild);
    },
    appendChild: function appendChild(newChild) {
      return this.insertBefore(newChild, null);
    },
    hasChildNodes: function hasChildNodes() {
      return this.firstChild != null;
    },
    cloneNode: function cloneNode(deep) {
      return _cloneNode(this.ownerDocument || this, this, deep);
    },
    normalize: function normalize() {
      var child = this.firstChild;

      while (child) {
        var next = child.nextSibling;

        if (next && next.nodeType == TEXT_NODE && child.nodeType == TEXT_NODE) {
          this.removeChild(next);
          child.appendData(next.data);
        } else {
          child.normalize();
          child = next;
        }
      }
    },
    isSupported: function isSupported(feature, version) {
      return this.ownerDocument.implementation.hasFeature(feature, version);
    },
    hasAttributes: function hasAttributes() {
      return this.attributes.length > 0;
    },
    lookupPrefix: function lookupPrefix(namespaceURI) {
      var el = this;

      while (el) {
        var map = el._nsMap;

        if (map) {
          for (var n in map) {
            if (map[n] == namespaceURI) {
              return n;
            }
          }
        }

        el = el.nodeType == 2 ? el.ownerDocument : el.parentNode;
      }

      return null;
    },
    lookupNamespaceURI: function lookupNamespaceURI(prefix) {
      var el = this;

      while (el) {
        var map = el._nsMap;

        if (map) {
          if (prefix in map) {
            return map[prefix];
          }
        }

        el = el.nodeType == 2 ? el.ownerDocument : el.parentNode;
      }

      return null;
    },
    isDefaultNamespace: function isDefaultNamespace(namespaceURI) {
      var prefix = this.lookupPrefix(namespaceURI);
      return prefix == null;
    }
  };

  function _xmlEncoder(c) {
    return c == "<" && "&lt;" || c == ">" && "&gt;" || c == "&" && "&amp;" || c == '"' && "&quot;" || "&#" + c.charCodeAt() + ";";
  }

  copy(NodeType, Node);
  copy(NodeType, Node.prototype);

  function _visitNode(node, callback) {
    if (callback(node)) {
      return true;
    }

    if (node = node.firstChild) {
      do {
        if (_visitNode(node, callback)) {
          return true;
        }
      } while (node = node.nextSibling);
    }
  }

  function Document() {}

  function _onAddAttribute(doc, el, newAttr) {
    doc && doc._inc++;
    var ns = newAttr.namespaceURI;

    if (ns == "http://www.w3.org/2000/xmlns/") {
      el._nsMap[newAttr.prefix ? newAttr.localName : ""] = newAttr.value;
    }
  }

  function _onRemoveAttribute(doc, el, newAttr, remove) {
    doc && doc._inc++;
    var ns = newAttr.namespaceURI;

    if (ns == "http://www.w3.org/2000/xmlns/") {
      delete el._nsMap[newAttr.prefix ? newAttr.localName : ""];
    }
  }

  function _onUpdateChild(doc, el, newChild) {
    if (doc && doc._inc) {
      doc._inc++;
      var cs = el.childNodes;

      if (newChild) {
        cs[cs.length++] = newChild;
      } else {
        var child = el.firstChild;
        var i = 0;

        while (child) {
          cs[i++] = child;
          child = child.nextSibling;
        }

        cs.length = i;
      }
    }
  }

  function _removeChild(parentNode, child) {
    var previous = child.previousSibling;
    var next = child.nextSibling;

    if (previous) {
      previous.nextSibling = next;
    } else {
      parentNode.firstChild = next;
    }

    if (next) {
      next.previousSibling = previous;
    } else {
      parentNode.lastChild = previous;
    }

    _onUpdateChild(parentNode.ownerDocument, parentNode);

    return child;
  }

  function _insertBefore(parentNode, newChild, nextChild) {
    var cp = newChild.parentNode;

    if (cp) {
      cp.removeChild(newChild); //remove and update
    }

    if (newChild.nodeType === DOCUMENT_FRAGMENT_NODE) {
      var newFirst = newChild.firstChild;

      if (newFirst == null) {
        return newChild;
      }

      var newLast = newChild.lastChild;
    } else {
      newFirst = newLast = newChild;
    }

    var pre = nextChild ? nextChild.previousSibling : parentNode.lastChild;
    newFirst.previousSibling = pre;
    newLast.nextSibling = nextChild;

    if (pre) {
      pre.nextSibling = newFirst;
    } else {
      parentNode.firstChild = newFirst;
    }

    if (nextChild == null) {
      parentNode.lastChild = newLast;
    } else {
      nextChild.previousSibling = newLast;
    }

    do {
      newFirst.parentNode = parentNode;
    } while (newFirst !== newLast && (newFirst = newFirst.nextSibling));

    _onUpdateChild(parentNode.ownerDocument || parentNode, parentNode);

    if (newChild.nodeType == DOCUMENT_FRAGMENT_NODE) {
      newChild.firstChild = newChild.lastChild = null;
    }

    return newChild;
  }

  function _appendSingleChild(parentNode, newChild) {
    var cp = newChild.parentNode;

    if (cp) {
      var pre = parentNode.lastChild;
      cp.removeChild(newChild); //remove and update

      var pre = parentNode.lastChild;
    }

    var pre = parentNode.lastChild;
    newChild.parentNode = parentNode;
    newChild.previousSibling = pre;
    newChild.nextSibling = null;

    if (pre) {
      pre.nextSibling = newChild;
    } else {
      parentNode.firstChild = newChild;
    }

    parentNode.lastChild = newChild;

    _onUpdateChild(parentNode.ownerDocument, parentNode, newChild);

    return newChild;
  }

  Document.prototype = {
    nodeName: "#document",
    nodeType: DOCUMENT_NODE,
    doctype: null,
    documentElement: null,
    _inc: 1,
    insertBefore: function insertBefore(newChild, refChild) {
      //raises
      if (newChild.nodeType == DOCUMENT_FRAGMENT_NODE) {
        var child = newChild.firstChild;

        while (child) {
          var next = child.nextSibling;
          this.insertBefore(child, refChild);
          child = next;
        }

        return newChild;
      }

      if (this.documentElement == null && newChild.nodeType == 1) {
        this.documentElement = newChild;
      }

      return _insertBefore(this, newChild, refChild), newChild.ownerDocument = this, newChild;
    },
    removeChild: function removeChild(oldChild) {
      if (this.documentElement == oldChild) {
        this.documentElement = null;
      }

      return _removeChild(this, oldChild);
    },
    importNode: function importNode(importedNode, deep) {
      return _importNode(this, importedNode, deep);
    },
    getElementById: function getElementById(id) {
      var rtv = null;

      _visitNode(this.documentElement, function (node) {
        if (node.nodeType == 1) {
          if (node.getAttribute("id") == id) {
            rtv = node;
            return true;
          }
        }
      });

      return rtv;
    },
    createElement: function createElement(tagName) {
      var node = new Element();
      node.ownerDocument = this;
      node.nodeName = tagName;
      node.tagName = tagName;
      node.childNodes = new NodeList();
      var attrs = node.attributes = new NamedNodeMap();
      attrs._ownerElement = node;
      return node;
    },
    createDocumentFragment: function createDocumentFragment() {
      var node = new DocumentFragment();
      node.ownerDocument = this;
      node.childNodes = new NodeList();
      return node;
    },
    createTextNode: function createTextNode(data) {
      var node = new Text();
      node.ownerDocument = this;
      node.appendData(data);
      return node;
    },
    createComment: function createComment(data) {
      var node = new Comment();
      node.ownerDocument = this;
      node.appendData(data);
      return node;
    },
    createCDATASection: function createCDATASection(data) {
      var node = new CDATASection();
      node.ownerDocument = this;
      node.appendData(data);
      return node;
    },
    createProcessingInstruction: function createProcessingInstruction(target, data) {
      var node = new ProcessingInstruction();
      node.ownerDocument = this;
      node.tagName = node.target = target;
      node.nodeValue = node.data = data;
      return node;
    },
    createAttribute: function createAttribute(name) {
      var node = new Attr();
      node.ownerDocument = this;
      node.name = name;
      node.nodeName = name;
      node.localName = name;
      node.specified = true;
      return node;
    },
    createEntityReference: function createEntityReference(name) {
      var node = new EntityReference();
      node.ownerDocument = this;
      node.nodeName = name;
      return node;
    },
    createElementNS: function createElementNS(namespaceURI, qualifiedName) {
      var node = new Element();
      var pl = qualifiedName.split(":");
      var attrs = node.attributes = new NamedNodeMap();
      node.childNodes = new NodeList();
      node.ownerDocument = this;
      node.nodeName = qualifiedName;
      node.tagName = qualifiedName;
      node.namespaceURI = namespaceURI;

      if (pl.length == 2) {
        node.prefix = pl[0];
        node.localName = pl[1];
      } else {
        node.localName = qualifiedName;
      }

      attrs._ownerElement = node;
      return node;
    },
    createAttributeNS: function createAttributeNS(namespaceURI, qualifiedName) {
      var node = new Attr();
      var pl = qualifiedName.split(":");
      node.ownerDocument = this;
      node.nodeName = qualifiedName;
      node.name = qualifiedName;
      node.namespaceURI = namespaceURI;
      node.specified = true;

      if (pl.length == 2) {
        node.prefix = pl[0];
        node.localName = pl[1];
      } else {
        node.localName = qualifiedName;
      }

      return node;
    }
  };

  _extends(Document, Node);

  function Element() {
    this._nsMap = {};
  }

  Element.prototype = {
    nodeType: ELEMENT_NODE,
    hasAttribute: function hasAttribute(name) {
      return this.getAttributeNode(name) != null;
    },
    getAttribute: function getAttribute(name) {
      var attr = this.getAttributeNode(name);
      return attr && attr.value || "";
    },
    getAttributeNode: function getAttributeNode(name) {
      return this.attributes.getNamedItem(name);
    },
    setAttribute: function setAttribute(name, value) {
      var attr = this.ownerDocument.createAttribute(name);
      attr.value = attr.nodeValue = "" + value;
      this.setAttributeNode(attr);
    },
    removeAttribute: function removeAttribute(name) {
      var attr = this.getAttributeNode(name);
      attr && this.removeAttributeNode(attr);
    },
    appendChild: function appendChild(newChild) {
      if (newChild.nodeType === DOCUMENT_FRAGMENT_NODE) {
        return this.insertBefore(newChild, null);
      } else {
        return _appendSingleChild(this, newChild);
      }
    },
    setAttributeNode: function setAttributeNode(newAttr) {
      return this.attributes.setNamedItem(newAttr);
    },
    setAttributeNodeNS: function setAttributeNodeNS(newAttr) {
      return this.attributes.setNamedItemNS(newAttr);
    },
    removeAttributeNode: function removeAttributeNode(oldAttr) {
      return this.attributes.removeNamedItem(oldAttr.nodeName);
    },
    removeAttributeNS: function removeAttributeNS(namespaceURI, localName) {
      var old = this.getAttributeNodeNS(namespaceURI, localName);
      old && this.removeAttributeNode(old);
    },
    hasAttributeNS: function hasAttributeNS(namespaceURI, localName) {
      return this.getAttributeNodeNS(namespaceURI, localName) != null;
    },
    getAttributeNS: function getAttributeNS(namespaceURI, localName) {
      var attr = this.getAttributeNodeNS(namespaceURI, localName);
      return attr && attr.value || "";
    },
    setAttributeNS: function setAttributeNS(namespaceURI, qualifiedName, value) {
      var attr = this.ownerDocument.createAttributeNS(namespaceURI, qualifiedName);
      attr.value = attr.nodeValue = "" + value;
      this.setAttributeNode(attr);
    },
    getAttributeNodeNS: function getAttributeNodeNS(namespaceURI, localName) {
      return this.attributes.getNamedItemNS(namespaceURI, localName);
    },
    getElementsByTagName: function getElementsByTagName(tagName) {
      return new LiveNodeList(this, function (base) {
        var ls = [];

        _visitNode(base, function (node) {
          if (node !== base && node.nodeType == ELEMENT_NODE && (tagName === "*" || node.tagName == tagName)) {
            ls.push(node);
          }
        });

        return ls;
      });
    },
    getElementsByTagNameNS: function getElementsByTagNameNS(namespaceURI, localName) {
      return new LiveNodeList(this, function (base) {
        var ls = [];

        _visitNode(base, function (node) {
          if (node !== base && node.nodeType === ELEMENT_NODE && (namespaceURI === "*" || node.namespaceURI === namespaceURI) && (localName === "*" || node.localName == localName)) {
            ls.push(node);
          }
        });

        return ls;
      });
    }
  };
  Document.prototype.getElementsByTagName = Element.prototype.getElementsByTagName;
  Document.prototype.getElementsByTagNameNS = Element.prototype.getElementsByTagNameNS;

  _extends(Element, Node);

  function Attr() {}

  Attr.prototype.nodeType = ATTRIBUTE_NODE;

  _extends(Attr, Node);

  function CharacterData() {}

  CharacterData.prototype = {
    data: "",
    substringData: function substringData(offset, count) {
      return this.data.substring(offset, offset + count);
    },
    appendData: function appendData(text) {
      text = this.data + text;
      this.nodeValue = this.data = text;
      this.length = text.length;
    },
    insertData: function insertData(offset, text) {
      this.replaceData(offset, 0, text);
    },
    appendChild: function appendChild(newChild) {
      throw new Error(ExceptionMessage[3]);
      return Node.prototype.appendChild.apply(this, arguments);
    },
    deleteData: function deleteData(offset, count) {
      this.replaceData(offset, count, "");
    },
    replaceData: function replaceData(offset, count, text) {
      var start = this.data.substring(0, offset);
      var end = this.data.substring(offset + count);
      text = start + text + end;
      this.nodeValue = this.data = text;
      this.length = text.length;
    }
  };

  _extends(CharacterData, Node);

  function Text() {}

  Text.prototype = {
    nodeName: "#text",
    nodeType: TEXT_NODE,
    splitText: function splitText(offset) {
      var text = this.data;
      var newText = text.substring(offset);
      text = text.substring(0, offset);
      this.data = this.nodeValue = text;
      this.length = text.length;
      var newNode = this.ownerDocument.createTextNode(newText);

      if (this.parentNode) {
        this.parentNode.insertBefore(newNode, this.nextSibling);
      }

      return newNode;
    }
  };

  _extends(Text, CharacterData);

  function Comment() {}

  Comment.prototype = {
    nodeName: "#comment",
    nodeType: COMMENT_NODE
  };

  _extends(Comment, CharacterData);

  function CDATASection() {}

  CDATASection.prototype = {
    nodeName: "#cdata-section",
    nodeType: CDATA_SECTION_NODE
  };

  _extends(CDATASection, CharacterData);

  function DocumentType() {}

  DocumentType.prototype.nodeType = DOCUMENT_TYPE_NODE;

  _extends(DocumentType, Node);

  function Notation() {}

  Notation.prototype.nodeType = NOTATION_NODE;

  _extends(Notation, Node);

  function Entity() {}

  Entity.prototype.nodeType = ENTITY_NODE;

  _extends(Entity, Node);

  function EntityReference() {}

  EntityReference.prototype.nodeType = ENTITY_REFERENCE_NODE;

  _extends(EntityReference, Node);

  function DocumentFragment() {}

  DocumentFragment.prototype.nodeName = "#document-fragment";
  DocumentFragment.prototype.nodeType = DOCUMENT_FRAGMENT_NODE;

  _extends(DocumentFragment, Node);

  function ProcessingInstruction() {}

  ProcessingInstruction.prototype.nodeType = PROCESSING_INSTRUCTION_NODE;

  _extends(ProcessingInstruction, Node);

  function XMLSerializer() {}

  XMLSerializer.prototype.serializeToString = function (node) {
    var buf = [];
    serializeToString(node, buf);
    return buf.join("");
  };

  Node.prototype.toString = function () {
    return XMLSerializer.prototype.serializeToString(this);
  };

  function serializeToString(node, buf) {
    switch (node.nodeType) {
      case ELEMENT_NODE:
        var attrs = node.attributes;
        var len = attrs.length;
        var child = node.firstChild;
        var nodeName = node.tagName;
        var isHTML = htmlns === node.namespaceURI;
        buf.push("<", nodeName);

        for (var i = 0; i < len; i++) {
          serializeToString(attrs.item(i), buf, isHTML);
        }

        if (child || isHTML && !/^(?:meta|link|img|br|hr|input|button)$/i.test(nodeName)) {
          buf.push(">");

          if (isHTML && /^script$/i.test(nodeName)) {
            if (child) {
              buf.push(child.data);
            }
          } else {
            while (child) {
              serializeToString(child, buf);
              child = child.nextSibling;
            }
          }

          buf.push("</", nodeName, ">");
        } else {
          buf.push("/>");
        }

        return;

      case DOCUMENT_NODE:
      case DOCUMENT_FRAGMENT_NODE:
        var child = node.firstChild;

        while (child) {
          serializeToString(child, buf);
          child = child.nextSibling;
        }

        return;

      case ATTRIBUTE_NODE:
        return buf.push(" ", node.name, '="', node.value.replace(/[<&"]/g, _xmlEncoder), '"');

      case TEXT_NODE:
        return buf.push(node.data.replace(/[<&]/g, _xmlEncoder));

      case CDATA_SECTION_NODE:
        return buf.push("<![CDATA[", node.data, "]]>");

      case COMMENT_NODE:
        return buf.push("<!--", node.data, "-->");

      case DOCUMENT_TYPE_NODE:
        var pubid = node.publicId;
        var sysid = node.systemId;
        buf.push("<!DOCTYPE ", node.name);

        if (pubid) {
          buf.push(' PUBLIC "', pubid);

          if (sysid && sysid != ".") {
            buf.push('" "', sysid);
          }

          buf.push('">');
        } else if (sysid && sysid != ".") {
          buf.push(' SYSTEM "', sysid, '">');
        } else {
          var sub = node.internalSubset;

          if (sub) {
            buf.push(" [", sub, "]");
          }

          buf.push(">");
        }

        return;

      case PROCESSING_INSTRUCTION_NODE:
        return buf.push("<?", node.target, " ", node.data, "?>");

      case ENTITY_REFERENCE_NODE:
        return buf.push("&", node.nodeName, ";");

      default:
        buf.push("??", node.nodeName);
    }
  }

  function _importNode(doc, node, deep) {
    var node2;

    switch (node.nodeType) {
      case ELEMENT_NODE:
        node2 = node.cloneNode(false);
        node2.ownerDocument = doc;

      case DOCUMENT_FRAGMENT_NODE:
        break;

      case ATTRIBUTE_NODE:
        deep = true;
        break;
    }

    if (!node2) {
      node2 = node.cloneNode(false); //false
    }

    node2.ownerDocument = doc;
    node2.parentNode = null;

    if (deep) {
      var child = node.firstChild;

      while (child) {
        node2.appendChild(_importNode(doc, child, deep));
        child = child.nextSibling;
      }
    }

    return node2;
  }

  function _cloneNode(doc, node, deep) {
    var node2 = new node.constructor();

    for (var n in node) {
      var v = node[n];

      if (_typeof(v) != "object") {
        if (v != node2[n]) {
          node2[n] = v;
        }
      }
    }

    if (node.childNodes) {
      node2.childNodes = new NodeList();
    }

    node2.ownerDocument = doc;

    switch (node2.nodeType) {
      case ELEMENT_NODE:
        var attrs = node.attributes;
        var attrs2 = node2.attributes = new NamedNodeMap();
        var len = attrs.length;
        attrs2._ownerElement = node2;

        for (var i = 0; i < len; i++) {
          node2.setAttributeNode(_cloneNode(doc, attrs.item(i), true));
        }

        break;

      case ATTRIBUTE_NODE:
        deep = true;
    }

    if (deep) {
      var child = node.firstChild;

      while (child) {
        node2.appendChild(_cloneNode(doc, child, deep));
        child = child.nextSibling;
      }
    }

    return node2;
  }

  function __set__(object, key, value) {
    object[key] = value;
  }

  try {
    if (Object.defineProperty) {
      Object.defineProperty(LiveNodeList.prototype, "length", {
        get: function get() {
          _updateLiveList(this);

          return this.$$length;
        }
      });
      Object.defineProperty(Node.prototype, "textContent", {
        get: function get() {
          return getTextContent(this);
        },
        set: function set(data) {
          switch (this.nodeType) {
            case 1:
            case 11:
              while (this.firstChild) {
                this.removeChild(this.firstChild);
              }

              if (data || String(data)) {
                this.appendChild(this.ownerDocument.createTextNode(data));
              }

              break;

            default:
              this.data = data;
              this.value = value;
              this.nodeValue = data;
          }
        }
      });

      function getTextContent(node) {
        switch (node.nodeType) {
          case 1:
          case 11:
            var buf = [];
            node = node.firstChild;

            while (node) {
              if (node.nodeType !== 7 && node.nodeType !== 8) {
                buf.push(getTextContent(node));
              }

              node = node.nextSibling;
            }

            return buf.join("");

          default:
            return node.nodeValue;
        }
      }

      __set__ = function __set__(object, key, value) {
        object["$$" + key] = value;
      };
    }
  } catch (e) {//ie8
  }

  return DOMImplementation;
});
ace.define("ace/mode/uu5/dom-parser", ["require", "exports", "module", "ace/mode/uu5/sax", "ace/mode/uu5/dom"], function (require, exports, module) {
  "use strict";

  var XMLReader = require("./sax"),
      DOMImplementation = require("./dom");

  function DOMParser(options) {
    this.options = options || {
      locator: {}
    };
  }

  DOMParser.prototype.parseFromString = function (source, mimeType, entityMap) {
    // NOTE Added parameter entityMap, removed local variable.
    var options = this.options;
    var sax = new XMLReader();
    var domBuilder = options.domBuilder || new DOMHandler(); //contentHandler and LexicalHandler

    var errorHandler = options.errorHandler;
    var locator = options.locator;
    var defaultNSMap = options.xmlns || {};

    if (locator) {
      domBuilder.setDocumentLocator(locator);
    }

    sax.errorHandler = buildErrorHandler(errorHandler, domBuilder, locator);
    sax.domBuilder = options.domBuilder || domBuilder;

    if (/\/x?html?$/.test(mimeType)) {
      entityMap.nbsp = "\xa0";
      entityMap.copy = "\xa9";
      defaultNSMap[""] = "http://www.w3.org/1999/xhtml";
    }

    if (source) {
      sax.parse(source, defaultNSMap, entityMap);
    } else {
      sax.errorHandler.error("invalid document source");
    }

    return domBuilder.document;
  };

  function buildErrorHandler(errorImpl, domBuilder, locator) {
    if (!errorImpl) {
      if (domBuilder instanceof DOMHandler) {
        return domBuilder;
      }

      errorImpl = domBuilder;
    }

    var errorHandler = {};
    var isCallback = errorImpl instanceof Function;
    locator = locator || {};

    function build(key) {
      var fn = errorImpl[key];

      if (!fn) {
        if (isCallback) {
          fn = errorImpl.length == 2 ? function (msg) {
            errorImpl(key, msg);
          } : errorImpl;
        } else {
          var i = arguments.length;

          while (--i) {
            if (fn = errorImpl[arguments[i]]) {
              break;
            }
          }
        }
      }

      errorHandler[key] = fn && function (msg) {
        fn(msg + _locator(locator), msg, locator);
      } || function () {};
    }

    build("warning", "warn");
    build("error", "warn", "warning");
    build("fatalError", "warn", "warning", "error");
    return errorHandler;
  }

  function DOMHandler() {
    this.cdata = false;
  }

  function position(locator, node) {
    node.lineNumber = locator.lineNumber;
    node.columnNumber = locator.columnNumber;
  }

  DOMHandler.prototype = {
    startDocument: function startDocument() {
      this.document = new DOMImplementation().createDocument(null, null, null);

      if (this.locator) {
        this.document.documentURI = this.locator.systemId;
      }
    },
    startElement: function startElement(namespaceURI, localName, qName, attrs) {
      var doc = this.document;
      var el = doc.createElementNS(namespaceURI, qName || localName);
      var len = attrs.length;
      appendElement(this, el);
      this.currentElement = el;
      this.locator && position(this.locator, el);

      for (var i = 0; i < len; i++) {
        var namespaceURI = attrs.getURI(i);
        var value = attrs.getValue(i);
        var qName = attrs.getQName(i);
        var attr = doc.createAttributeNS(namespaceURI, qName);

        if (attr.getOffset) {
          position(attr.getOffset(1), attr);
        }

        attr.value = attr.nodeValue = value;
        el.setAttributeNode(attr);
      }
    },
    endElement: function endElement(namespaceURI, localName, qName) {
      var current = this.currentElement;
      var tagName = current.tagName;
      this.currentElement = current.parentNode;
    },
    startPrefixMapping: function startPrefixMapping(prefix, uri) {},
    endPrefixMapping: function endPrefixMapping(prefix) {},
    processingInstruction: function processingInstruction(target, data) {
      var ins = this.document.createProcessingInstruction(target, data);
      this.locator && position(this.locator, ins);
      appendElement(this, ins);
    },
    ignorableWhitespace: function ignorableWhitespace(ch, start, length) {},
    characters: function characters(chars, start, length) {
      chars = _toString.apply(this, arguments);

      if (this.currentElement && chars) {
        if (this.cdata) {
          var charNode = this.document.createCDATASection(chars);
          this.currentElement.appendChild(charNode);
        } else {
          var charNode = this.document.createTextNode(chars);
          this.currentElement.appendChild(charNode);
        }

        this.locator && position(this.locator, charNode);
      }
    },
    skippedEntity: function skippedEntity(name) {},
    endDocument: function endDocument() {
      this.document.normalize();
    },
    setDocumentLocator: function setDocumentLocator(locator) {
      if (this.locator = locator) {
        // && !('lineNumber' in locator)){
        locator.lineNumber = 0;
      }
    },
    comment: function comment(chars, start, length) {
      chars = _toString.apply(this, arguments);
      var comm = this.document.createComment(chars);
      this.locator && position(this.locator, comm);
      appendElement(this, comm);
    },
    startCDATA: function startCDATA() {
      this.cdata = true;
    },
    endCDATA: function endCDATA() {
      this.cdata = false;
    },
    startDTD: function startDTD(name, publicId, systemId) {
      var impl = this.document.implementation;

      if (impl && impl.createDocumentType) {
        var dt = impl.createDocumentType(name, publicId, systemId);
        this.locator && position(this.locator, dt);
        appendElement(this, dt);
      }
    },
    warning: function warning(error) {
      console.warn(error, _locator(this.locator));
    },
    error: function error(_error) {
      console.error(_error, _locator(this.locator));
    },
    fatalError: function fatalError(error) {
      console.error(error, _locator(this.locator));
      throw error;
    }
  };

  function _locator(l) {
    if (l) {
      return "\n@" + (l.systemId || "") + "#[line:" + l.lineNumber + ",col:" + l.columnNumber + "]";
    }
  }

  function _toString(chars, start, length) {
    if (typeof chars == "string") {
      return chars.substr(start, length);
    } else {
      //java sax connect width xmldom on rhino(what about: "? && !(chars instanceof String)")
      if (chars.length >= start + length || start) {
        return new java.lang.String(chars, start, length) + "";
      }

      return chars;
    }
  }

  "endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g, function (key) {
    DOMHandler.prototype[key] = function () {
      return null;
    };
  });

  function appendElement(hander, node) {
    if (!hander.currentElement) {
      hander.document.appendChild(node);
    } else {
      hander.currentElement.appendChild(node);
    }
  } //appendChild and setAttributeNS are preformance key


  return {
    DOMParser: DOMParser
  };
});
ace.define("ace/mode/uu5_worker", ["require", "exports", "module", "ace/lib/oop", "ace/lib/lang", "ace/worker/mirror", "ace/mode/uu5/dom-parser"], function (require, exports, module) {
  "use strict";

  var oop = require("../lib/oop");

  var lang = require("../lib/lang");

  var Mirror = require("../worker/mirror").Mirror;

  var DOMParser = require("./uu5/dom-parser").DOMParser;

  var Worker = exports.Worker = function (sender) {
    Mirror.call(this, sender);
    this.setTimeout(400);
    this.context = null;
  };

  oop.inherits(Worker, Mirror);
  (function () {
    this.setOptions = function (options) {
      this.context = options.context;
    };

    this.onUpdate = function () {
      var value = this.doc.getValue();
      if (!value) return;
      var parser = new DOMParser();
      var errors = [];
      parser.options.errorHandler = {
        fatalError: function fatalError(fullMsg, errorMsg, locator) {
          errors.push({
            row: locator.lineNumber,
            column: locator.columnNumber,
            text: errorMsg,
            type: "error"
          });
        },
        error: function error(fullMsg, errorMsg, locator) {
          errors.push({
            row: locator.lineNumber,
            column: locator.columnNumber,
            text: errorMsg,
            type: "error"
          });
        },
        warning: function warning(fullMsg, errorMsg, locator) {
          errors.push({
            row: locator.lineNumber,
            column: locator.columnNumber,
            text: errorMsg,
            type: "warning"
          });
        }
      };
      parser.parseFromString(value, undefined, this.context.htmlEntities); // NOTE Added parameter.

      errors.sort(function (a, b) {
        return a.row - b.row || a.column - b.column;
      });
      this.sender.emit("error", errors);
    };
  }).call(Worker.prototype);
});
ace.define("ace/lib/es5-shim", ["require", "exports", "module"], function (require, exports, module) {
  function Empty() {}

  if (!Function.prototype.bind) {
    Function.prototype.bind = function bind(that) {
      // .length is 1
      var target = this;

      if (typeof target != "function") {
        throw new TypeError("Function.prototype.bind called on incompatible " + target);
      }

      var args = slice.call(arguments, 1); // for normal call

      var bound = function bound() {
        if (this instanceof bound) {
          var result = target.apply(this, args.concat(slice.call(arguments)));

          if (Object(result) === result) {
            return result;
          }

          return this;
        } else {
          return target.apply(that, args.concat(slice.call(arguments)));
        }
      };

      if (target.prototype) {
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }

      return bound;
    };
  }

  var call = Function.prototype.call;
  var prototypeOfArray = Array.prototype;
  var prototypeOfObject = Object.prototype;
  var slice = prototypeOfArray.slice;

  var _toString = call.bind(prototypeOfObject.toString);

  var owns = call.bind(prototypeOfObject.hasOwnProperty);
  var defineGetter;
  var defineSetter;
  var lookupGetter;
  var lookupSetter;
  var supportsAccessors;

  if (supportsAccessors = owns(prototypeOfObject, "__defineGetter__")) {
    defineGetter = call.bind(prototypeOfObject.__defineGetter__);
    defineSetter = call.bind(prototypeOfObject.__defineSetter__);
    lookupGetter = call.bind(prototypeOfObject.__lookupGetter__);
    lookupSetter = call.bind(prototypeOfObject.__lookupSetter__);
  }

  if ([1, 2].splice(0).length != 2) {
    if (function () {
      // test IE < 9 to splice bug - see issue #138
      function makeArray(l) {
        var a = new Array(l + 2);
        a[0] = a[1] = 0;
        return a;
      }

      var array = [],
          lengthBefore;
      array.splice.apply(array, makeArray(20));
      array.splice.apply(array, makeArray(26));
      lengthBefore = array.length; //46

      array.splice(5, 0, "XXX"); // add one element

      lengthBefore + 1 == array.length;

      if (lengthBefore + 1 == array.length) {
        return true; // has right splice implementation without bugs
      }
    }()) {
      //IE 6/7
      var array_splice = Array.prototype.splice;

      Array.prototype.splice = function (start, deleteCount) {
        if (!arguments.length) {
          return [];
        } else {
          return array_splice.apply(this, [start === void 0 ? 0 : start, deleteCount === void 0 ? this.length - start : deleteCount].concat(slice.call(arguments, 2)));
        }
      };
    } else {
      //IE8
      Array.prototype.splice = function (pos, removeCount) {
        var length = this.length;

        if (pos > 0) {
          if (pos > length) pos = length;
        } else if (pos == void 0) {
          pos = 0;
        } else if (pos < 0) {
          pos = Math.max(length + pos, 0);
        }

        if (!(pos + removeCount < length)) removeCount = length - pos;
        var removed = this.slice(pos, pos + removeCount);
        var insert = slice.call(arguments, 2);
        var add = insert.length;

        if (pos === length) {
          if (add) {
            this.push.apply(this, insert);
          }
        } else {
          var remove = Math.min(removeCount, length - pos);
          var tailOldPos = pos + remove;
          var tailNewPos = tailOldPos + add - remove;
          var tailCount = length - tailOldPos;
          var lengthAfterRemove = length - remove;

          if (tailNewPos < tailOldPos) {
            // case A
            for (var i = 0; i < tailCount; ++i) {
              this[tailNewPos + i] = this[tailOldPos + i];
            }
          } else if (tailNewPos > tailOldPos) {
            // case B
            for (i = tailCount; i--;) {
              this[tailNewPos + i] = this[tailOldPos + i];
            }
          } // else, add == remove (nothing to do)


          if (add && pos === lengthAfterRemove) {
            this.length = lengthAfterRemove; // truncate array

            this.push.apply(this, insert);
          } else {
            this.length = lengthAfterRemove + add; // reserves space

            for (i = 0; i < add; ++i) {
              this[pos + i] = insert[i];
            }
          }
        }

        return removed;
      };
    }
  }

  if (!Array.isArray) {
    Array.isArray = function isArray(obj) {
      return _toString(obj) == "[object Array]";
    };
  }

  var boxedString = Object("a"),
      splitString = boxedString[0] != "a" || !(0 in boxedString);

  if (!Array.prototype.forEach) {
    Array.prototype.forEach = function forEach(fun
    /*, thisp*/
    ) {
      var object = toObject(this),
          self = splitString && _toString(this) == "[object String]" ? this.split("") : object,
          thisp = arguments[1],
          i = -1,
          length = self.length >>> 0;

      if (_toString(fun) != "[object Function]") {
        throw new TypeError(); // TODO message
      }

      while (++i < length) {
        if (i in self) {
          fun.call(thisp, self[i], i, object);
        }
      }
    };
  }

  if (!Array.prototype.map) {
    Array.prototype.map = function map(fun
    /*, thisp*/
    ) {
      var object = toObject(this),
          self = splitString && _toString(this) == "[object String]" ? this.split("") : object,
          length = self.length >>> 0,
          result = Array(length),
          thisp = arguments[1];

      if (_toString(fun) != "[object Function]") {
        throw new TypeError(fun + " is not a function");
      }

      for (var i = 0; i < length; i++) {
        if (i in self) result[i] = fun.call(thisp, self[i], i, object);
      }

      return result;
    };
  }

  if (!Array.prototype.filter) {
    Array.prototype.filter = function filter(fun
    /*, thisp */
    ) {
      var object = toObject(this),
          self = splitString && _toString(this) == "[object String]" ? this.split("") : object,
          length = self.length >>> 0,
          result = [],
          value,
          thisp = arguments[1];

      if (_toString(fun) != "[object Function]") {
        throw new TypeError(fun + " is not a function");
      }

      for (var i = 0; i < length; i++) {
        if (i in self) {
          value = self[i];

          if (fun.call(thisp, value, i, object)) {
            result.push(value);
          }
        }
      }

      return result;
    };
  }

  if (!Array.prototype.every) {
    Array.prototype.every = function every(fun
    /*, thisp */
    ) {
      var object = toObject(this),
          self = splitString && _toString(this) == "[object String]" ? this.split("") : object,
          length = self.length >>> 0,
          thisp = arguments[1];

      if (_toString(fun) != "[object Function]") {
        throw new TypeError(fun + " is not a function");
      }

      for (var i = 0; i < length; i++) {
        if (i in self && !fun.call(thisp, self[i], i, object)) {
          return false;
        }
      }

      return true;
    };
  }

  if (!Array.prototype.some) {
    Array.prototype.some = function some(fun
    /*, thisp */
    ) {
      var object = toObject(this),
          self = splitString && _toString(this) == "[object String]" ? this.split("") : object,
          length = self.length >>> 0,
          thisp = arguments[1];

      if (_toString(fun) != "[object Function]") {
        throw new TypeError(fun + " is not a function");
      }

      for (var i = 0; i < length; i++) {
        if (i in self && fun.call(thisp, self[i], i, object)) {
          return true;
        }
      }

      return false;
    };
  }

  if (!Array.prototype.reduce) {
    Array.prototype.reduce = function reduce(fun
    /*, initial*/
    ) {
      var object = toObject(this),
          self = splitString && _toString(this) == "[object String]" ? this.split("") : object,
          length = self.length >>> 0;

      if (_toString(fun) != "[object Function]") {
        throw new TypeError(fun + " is not a function");
      }

      if (!length && arguments.length == 1) {
        throw new TypeError("reduce of empty array with no initial value");
      }

      var i = 0;
      var result;

      if (arguments.length >= 2) {
        result = arguments[1];
      } else {
        do {
          if (i in self) {
            result = self[i++];
            break;
          }

          if (++i >= length) {
            throw new TypeError("reduce of empty array with no initial value");
          }
        } while (true);
      }

      for (; i < length; i++) {
        if (i in self) {
          result = fun.call(void 0, result, self[i], i, object);
        }
      }

      return result;
    };
  }

  if (!Array.prototype.reduceRight) {
    Array.prototype.reduceRight = function reduceRight(fun
    /*, initial*/
    ) {
      var object = toObject(this),
          self = splitString && _toString(this) == "[object String]" ? this.split("") : object,
          length = self.length >>> 0;

      if (_toString(fun) != "[object Function]") {
        throw new TypeError(fun + " is not a function");
      }

      if (!length && arguments.length == 1) {
        throw new TypeError("reduceRight of empty array with no initial value");
      }

      var result,
          i = length - 1;

      if (arguments.length >= 2) {
        result = arguments[1];
      } else {
        do {
          if (i in self) {
            result = self[i--];
            break;
          }

          if (--i < 0) {
            throw new TypeError("reduceRight of empty array with no initial value");
          }
        } while (true);
      }

      do {
        if (i in this) {
          result = fun.call(void 0, result, self[i], i, object);
        }
      } while (i--);

      return result;
    };
  }

  if (!Array.prototype.indexOf || [0, 1].indexOf(1, 2) != -1) {
    Array.prototype.indexOf = function indexOf(sought
    /*, fromIndex */
    ) {
      var self = splitString && _toString(this) == "[object String]" ? this.split("") : toObject(this),
          length = self.length >>> 0;

      if (!length) {
        return -1;
      }

      var i = 0;

      if (arguments.length > 1) {
        i = toInteger(arguments[1]);
      }

      i = i >= 0 ? i : Math.max(0, length + i);

      for (; i < length; i++) {
        if (i in self && self[i] === sought) {
          return i;
        }
      }

      return -1;
    };
  }

  if (!Array.prototype.lastIndexOf || [0, 1].lastIndexOf(0, -3) != -1) {
    Array.prototype.lastIndexOf = function lastIndexOf(sought
    /*, fromIndex */
    ) {
      var self = splitString && _toString(this) == "[object String]" ? this.split("") : toObject(this),
          length = self.length >>> 0;

      if (!length) {
        return -1;
      }

      var i = length - 1;

      if (arguments.length > 1) {
        i = Math.min(i, toInteger(arguments[1]));
      }

      i = i >= 0 ? i : length - Math.abs(i);

      for (; i >= 0; i--) {
        if (i in self && sought === self[i]) {
          return i;
        }
      }

      return -1;
    };
  }

  if (!Object.getPrototypeOf) {
    Object.getPrototypeOf = function getPrototypeOf(object) {
      return object.__proto__ || (object.constructor ? object.constructor.prototype : prototypeOfObject);
    };
  }

  if (!Object.getOwnPropertyDescriptor) {
    var ERR_NON_OBJECT = "Object.getOwnPropertyDescriptor called on a " + "non-object: ";

    Object.getOwnPropertyDescriptor = function getOwnPropertyDescriptor(object, property) {
      if (_typeof(object) != "object" && typeof object != "function" || object === null) throw new TypeError(ERR_NON_OBJECT + object);
      if (!owns(object, property)) return;
      var descriptor, getter, setter;
      descriptor = {
        enumerable: true,
        configurable: true
      };

      if (supportsAccessors) {
        var prototype = object.__proto__;
        object.__proto__ = prototypeOfObject;
        var getter = lookupGetter(object, property);
        var setter = lookupSetter(object, property);
        object.__proto__ = prototype;

        if (getter || setter) {
          if (getter) descriptor.get = getter;
          if (setter) descriptor.set = setter;
          return descriptor;
        }
      }

      descriptor.value = object[property];
      return descriptor;
    };
  }

  if (!Object.getOwnPropertyNames) {
    Object.getOwnPropertyNames = function getOwnPropertyNames(object) {
      return Object.keys(object);
    };
  }

  if (!Object.create) {
    var createEmpty;

    if (Object.prototype.__proto__ === null) {
      createEmpty = function createEmpty() {
        return {
          __proto__: null
        };
      };
    } else {
      createEmpty = function createEmpty() {
        var empty = {};

        for (var i in empty) {
          empty[i] = null;
        }

        empty.constructor = empty.hasOwnProperty = empty.propertyIsEnumerable = empty.isPrototypeOf = empty.toLocaleString = empty.toString = empty.valueOf = empty.__proto__ = null;
        return empty;
      };
    }

    Object.create = function create(prototype, properties) {
      var object;

      if (prototype === null) {
        object = createEmpty();
      } else {
        if (_typeof(prototype) != "object") throw new TypeError("typeof prototype[" + _typeof(prototype) + "] != 'object'");

        var Type = function Type() {};

        Type.prototype = prototype;
        object = new Type();
        object.__proto__ = prototype;
      }

      if (properties !== void 0) Object.defineProperties(object, properties);
      return object;
    };
  }

  function doesDefinePropertyWork(object) {
    try {
      Object.defineProperty(object, "sentinel", {});
      return "sentinel" in object;
    } catch (exception) {}
  }

  if (Object.defineProperty) {
    var definePropertyWorksOnObject = doesDefinePropertyWork({});
    var definePropertyWorksOnDom = typeof document == "undefined" || doesDefinePropertyWork(document.createElement("div"));

    if (!definePropertyWorksOnObject || !definePropertyWorksOnDom) {
      var definePropertyFallback = Object.defineProperty;
    }
  }

  if (!Object.defineProperty || definePropertyFallback) {
    var ERR_NON_OBJECT_DESCRIPTOR = "Property description must be an object: ";
    var ERR_NON_OBJECT_TARGET = "Object.defineProperty called on non-object: ";
    var ERR_ACCESSORS_NOT_SUPPORTED = "getters & setters can not be defined " + "on this javascript engine";

    Object.defineProperty = function defineProperty(object, property, descriptor) {
      if (_typeof(object) != "object" && typeof object != "function" || object === null) throw new TypeError(ERR_NON_OBJECT_TARGET + object);
      if (_typeof(descriptor) != "object" && typeof descriptor != "function" || descriptor === null) throw new TypeError(ERR_NON_OBJECT_DESCRIPTOR + descriptor);

      if (definePropertyFallback) {
        try {
          return definePropertyFallback.call(Object, object, property, descriptor);
        } catch (exception) {}
      }

      if (owns(descriptor, "value")) {
        if (supportsAccessors && (lookupGetter(object, property) || lookupSetter(object, property))) {
          var prototype = object.__proto__;
          object.__proto__ = prototypeOfObject;
          delete object[property];
          object[property] = descriptor.value;
          object.__proto__ = prototype;
        } else {
          object[property] = descriptor.value;
        }
      } else {
        if (!supportsAccessors) throw new TypeError(ERR_ACCESSORS_NOT_SUPPORTED);
        if (owns(descriptor, "get")) defineGetter(object, property, descriptor.get);
        if (owns(descriptor, "set")) defineSetter(object, property, descriptor.set);
      }

      return object;
    };
  }

  if (!Object.defineProperties) {
    Object.defineProperties = function defineProperties(object, properties) {
      for (var property in properties) {
        if (owns(properties, property)) Object.defineProperty(object, property, properties[property]);
      }

      return object;
    };
  }

  if (!Object.seal) {
    Object.seal = function seal(object) {
      return object;
    };
  }

  if (!Object.freeze) {
    Object.freeze = function freeze(object) {
      return object;
    };
  }

  try {
    Object.freeze(function () {});
  } catch (exception) {
    Object.freeze = function freeze(freezeObject) {
      return function freeze(object) {
        if (typeof object == "function") {
          return object;
        } else {
          return freezeObject(object);
        }
      };
    }(Object.freeze);
  }

  if (!Object.preventExtensions) {
    Object.preventExtensions = function preventExtensions(object) {
      return object;
    };
  }

  if (!Object.isSealed) {
    Object.isSealed = function isSealed(object) {
      return false;
    };
  }

  if (!Object.isFrozen) {
    Object.isFrozen = function isFrozen(object) {
      return false;
    };
  }

  if (!Object.isExtensible) {
    Object.isExtensible = function isExtensible(object) {
      if (Object(object) === object) {
        throw new TypeError(); // TODO message
      }

      var name = "";

      while (owns(object, name)) {
        name += "?";
      }

      object[name] = true;
      var returnValue = owns(object, name);
      delete object[name];
      return returnValue;
    };
  }

  if (!Object.keys) {
    var hasDontEnumBug = true,
        dontEnums = ["toString", "toLocaleString", "valueOf", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "constructor"],
        dontEnumsLength = dontEnums.length;

    for (var key in {
      toString: null
    }) {
      hasDontEnumBug = false;
    }

    Object.keys = function keys(object) {
      if (_typeof(object) != "object" && typeof object != "function" || object === null) {
        throw new TypeError("Object.keys called on a non-object");
      }

      var keys = [];

      for (var name in object) {
        if (owns(object, name)) {
          keys.push(name);
        }
      }

      if (hasDontEnumBug) {
        for (var i = 0, ii = dontEnumsLength; i < ii; i++) {
          var dontEnum = dontEnums[i];

          if (owns(object, dontEnum)) {
            keys.push(dontEnum);
          }
        }
      }

      return keys;
    };
  }

  if (!Date.now) {
    Date.now = function now() {
      return new Date().getTime();
    };
  }

  var ws = "\t\n\x0B\f\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003" + "\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028" + "\u2029\uFEFF";

  if (!String.prototype.trim || ws.trim()) {
    ws = "[" + ws + "]";
    var trimBeginRegexp = new RegExp("^" + ws + ws + "*"),
        trimEndRegexp = new RegExp(ws + ws + "*$");

    String.prototype.trim = function trim() {
      return String(this).replace(trimBeginRegexp, "").replace(trimEndRegexp, "");
    };
  }

  function toInteger(n) {
    n = +n;

    if (n !== n) {
      // isNaN
      n = 0;
    } else if (n !== 0 && n !== 1 / 0 && n !== -(1 / 0)) {
      n = (n > 0 || -1) * Math.floor(Math.abs(n));
    }

    return n;
  }

  function isPrimitive(input) {
    var type = _typeof(input);

    return input === null || type === "undefined" || type === "boolean" || type === "number" || type === "string";
  }

  function toPrimitive(input) {
    var val, valueOf, toString;

    if (isPrimitive(input)) {
      return input;
    }

    valueOf = input.valueOf;

    if (typeof valueOf === "function") {
      val = valueOf.call(input);

      if (isPrimitive(val)) {
        return val;
      }
    }

    toString = input.toString;

    if (typeof toString === "function") {
      val = toString.call(input);

      if (isPrimitive(val)) {
        return val;
      }
    }

    throw new TypeError();
  }

  var toObject = function toObject(o) {
    if (o == null) {
      // this matches both null and undefined
      throw new TypeError("can't convert " + o + " to object");
    }

    return Object(o);
  };
});

/***/ }),
/* 4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _uu5string_parser_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
/* harmony import */ var _ace_issue_reporter_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(13);
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }



var ace = self.ace;
ace.define("ace/mode/uu5/sax", ["require", "exports", "module"], function (require, exports, module) {
  var AceUu5StringReportingParser = /*#__PURE__*/function () {
    function AceUu5StringReportingParser() {
      _classCallCheck(this, AceUu5StringReportingParser);
    }

    _createClass(AceUu5StringReportingParser, [{
      key: "parse",
      value: function parse(source, defaultNSMap, entityMap) {
        var domBuilder = this.domBuilder,
            errorHandler = this.errorHandler;
        var parser = new _uu5string_parser_js__WEBPACK_IMPORTED_MODULE_0__["default"]({
          entityMap: entityMap,
          issueReporter: new _ace_issue_reporter_js__WEBPACK_IMPORTED_MODULE_1__["default"]({
            aceDomBuilder: domBuilder,
            aceErrorHandler: errorHandler
          })
        });
        domBuilder.startDocument();
        var children = parser.parse(source);
        if (children) this._childrenToDom(children, domBuilder, domBuilder.document);
        domBuilder.endDocument();
      }
    }, {
      key: "_childrenToDom",
      value: function _childrenToDom(children, domBuilder, currentElement) {
        var _this = this;

        if (children == null || children === "") return;

        if (!Array.isArray(children)) {
          var text = domBuilder.document.createTextNode(children + "");
          currentElement.appendChild(text);
        } else {
          children.forEach(function (child) {
            if (child == null) return;

            if (typeof child === "string") {
              var _text = domBuilder.document.createTextNode(child);

              currentElement.appendChild(_text);
            } else if (_typeof(child) === "object" && child.tag) {
              // tag, attrs, children
              var el = domBuilder.document.createElement(child.tag);

              if (child.attrs) {
                for (var k in child.attrs) {
                  if (k && child.attrs[k] != null) el.setAttribute(k, child.attrs[k] + "");
                }
              }

              currentElement.appendChild(el);
              if (child.children) _this._childrenToDom(child.children, domBuilder, el);
            } else {
              console.error("Unsupported child when parsing uu5string in Ace editor:", child);
            }
          });
        }
      }
    }]);

    return AceUu5StringReportingParser;
  }();

  return AceUu5StringReportingParser;
});

/***/ }),
/* 5 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tools_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6);
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9);
/* harmony import */ var _uu5_json_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(12);
/* harmony import */ var _uu5_data_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(11);
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? Object(arguments[i]) : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }





/**
 * Parses uu5string deeply (attributes with uu5string, nested strings inside of uu5json, ...).
 * Errors / warning are reported using issueReporter class, they're not thrown. Reported
 * issues contain message, string being parsed and index where the issue occurred.
 */

var Parser = /*#__PURE__*/function () {
  function Parser() {
    var _this = this;

    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Parser);

    this.issueReporter = opts.issueReporter || {};
    this.entityMap = opts.entityMap || {};
    this._buildItem = this._buildItem.bind(this);
    this._nestedIssueReporter = {
      error: function error(message, parsingContext) {
        var _this$_reconstructOri = _this._reconstructOriginalIssueLocation(parsingContext),
            index = _this$_reconstructOri.index,
            string = _this$_reconstructOri.string;

        _this.issueReporter.error && _this.issueReporter.error(message, {
          index: index,
          string: string
        });
      },
      warning: function warning(message, parsingContext) {
        var _this$_reconstructOri2 = _this._reconstructOriginalIssueLocation(parsingContext),
            index = _this$_reconstructOri2.index,
            string = _this$_reconstructOri2.string;

        _this.issueReporter.warning && _this.issueReporter.warning(message, {
          index: index,
          string: string
        });
      }
    };
  }

  _createClass(Parser, [{
    key: "parse",
    value: function parse(uu5string) {
      var modUu5string = "<uu5string/>" + uu5string;
      var modParsingContext = {
        string: uu5string,
        index: 0,
        revertToUnparsedValueFns: [function (string) {
          return string.substr("<uu5string/>".length);
        }]
      };
      var children;

      try {
        children = _tools_js__WEBPACK_IMPORTED_MODULE_0__["default"].parseUu5String(modUu5string, this._buildItem, modParsingContext, this._nestedIssueReporter);
      } catch (e) {
        if (e.context) {
          this._nestedIssueReporter.error(e.message, e.context);

          children = e.partialResult || [];
        } else {
          throw e;
        }
      }

      return children;
    }
  }, {
    key: "_buildItem",
    value: function _buildItem(tag, propsString, children, isPairedTag, initFn, parent, parsingContext) {
      var _this2 = this;

      var result;

      if (!tag) {
        // text
        this._validateEntities(children, parsingContext);

        result = children;
      } else {
        // tag
        var attrs = {};

        var attrsParsingContext = _objectSpread({}, parsingContext, {
          index: parsingContext.index + 1 + tag.length
        });

        var buildAttr = function buildAttr(attr, parsingContext) {
          attrs[attr.name] = attr.rawValue;

          if (attr.rawValue) {
            if (attr.rawValue.match(_constants_js__WEBPACK_IMPORTED_MODULE_1__["UU5JSON_REGEXP"])) {
              // re-parse uu5json with validation of nested uu5strings in JSON.
              _this2._parseNestedStringsInUu5Json(attr.rawValue, parsingContext);
            } else if (!attr.rawValue.match(_constants_js__WEBPACK_IMPORTED_MODULE_1__["UU5STRING_REGEXP"]) && !attr.rawValue.match(_constants_js__WEBPACK_IMPORTED_MODULE_1__["UU5DATA_REGEXP"])) {
              _this2._validateEntities(attr.rawValue, parsingContext);
            }
          }

          return attr;
        };

        try {
          _tools_js__WEBPACK_IMPORTED_MODULE_0__["default"].parseUU5StringProps(propsString, this._buildItem, buildAttr, attrsParsingContext, this._nestedIssueReporter);
        } catch (e) {
          if (e.context) {
            this._nestedIssueReporter.error(e.message, e.context);
          } else {
            throw e;
          }
        }

        result = {
          tag: tag,
          attrs: attrs,
          children: children
        };
      }

      return result;
    }
  }, {
    key: "_parseNestedStringsInUu5Json",
    value: function _parseNestedStringsInUu5Json(uu5json, parentParsingContext) {
      var _this3 = this;

      _uu5_json_js__WEBPACK_IMPORTED_MODULE_2__["default"].parse(uu5json, function (attrKey, attrValue, attrValueParsingContext) {
        try {
          if (typeof attrValue !== "string") return;

          if (attrValue.match(_constants_js__WEBPACK_IMPORTED_MODULE_1__["UU5STRING_REGEXP"])) {
            var modText = attrValue.replace(/^\s+/, "");
            var modParsingContext = {
              string: modText,
              index: attrValue.length - modText.length,
              parentParsingContext: attrValueParsingContext
            };
            _tools_js__WEBPACK_IMPORTED_MODULE_0__["default"].parseUu5String(modText, _this3._buildItem, modParsingContext, _this3._nestedIssueReporter);
          } else if (attrValue.match(_constants_js__WEBPACK_IMPORTED_MODULE_1__["UU5JSON_REGEXP"])) {
            _this3._parseNestedStringsInUu5Json(attrValue, attrValueParsingContext);
          } else if (attrValue.match(_constants_js__WEBPACK_IMPORTED_MODULE_1__["UU5DATA_REGEXP"])) {
            _uu5_data_js__WEBPACK_IMPORTED_MODULE_3__["default"].parse(attrValue, attrValueParsingContext);
          }
        } catch (e) {
          if (e.context) {
            _this3._nestedIssueReporter.error(e.message, e.context);
          } else {
            // don't throw on nested uu5json-s (let the parsing continue)
            // TODO Maybe throw because parsing errors have always e.context?
            console.error(e);
          }
        }
      }, parentParsingContext);
    }
  }, {
    key: "_reconstructOriginalIssueLocation",
    value: function _reconstructOriginalIssueLocation(errorContext) {
      var rootString = errorContext.string,
          rootIndex = errorContext.index;
      var stringUptoIssue = rootString.substr(0, rootIndex || 0);
      var context = errorContext.parentParsingContext;

      while (context) {
        var _context = context,
            string = _context.string,
            index = _context.index,
            revertToUnparsedValueFns = _context.revertToUnparsedValueFns;

        if (revertToUnparsedValueFns) {
          stringUptoIssue = revertToUnparsedValueFns.reduceRight(function (result, fn) {
            return fn(result);
          }, stringUptoIssue);
        }

        stringUptoIssue = string.substr(0, index) + stringUptoIssue;
        rootString = context.string;
        context = context.parentParsingContext;
      }

      return {
        index: stringUptoIssue.length,
        string: rootString
      };
    }
  }, {
    key: "_validateEntities",
    value: function _validateEntities(text, parentParsingContext) {
      var _this4 = this;

      if (text) {
        text.replace(/&(\w+);/g, function (m, name, pos) {
          if (!(name in _this4.entityMap)) {
            _this4._nestedIssueReporter.warning("Entity ".concat(m, " at position ").concat(pos, " is not recognized."), {
              index: pos,
              string: text,
              parentParsingContext: parentParsingContext
            });
          }
        });
      }
    }
  }]);

  return Parser;
}();

/* harmony default export */ __webpack_exports__["default"] = (Parser);

/***/ }),
/* 6 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _symbols__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9);
/* harmony import */ var _uu5_environment_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(10);
/* harmony import */ var _uu5_common_tools_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(8);
/* harmony import */ var _uu5_data_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(11);
/* harmony import */ var _uu5_json_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(12);
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? Object(arguments[i]) : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }







var Tools = {
  /*
    Transform content into React components.
     @param content - array of UU5StringObjects, strings, numbers, booleans and UU5StringTemplates
    @param data - map with data for UU5String templates
    @param filterFn({tag, props}) - function to change tag and props used for rendering into components. Function is called for each descendant UU5StringObject before creation of React component. This function cannot change data of UU5StringObjects.
    @returns array of React components
   */
  contentToChildren: function contentToChildren(content, data, filterFn) {
    if (!content || !content.length) {
      return null;
    }

    return content.map(function (item) {
      return typeof item === "string" ? Tools.printTemplateToChildren(_uu5_environment_js__WEBPACK_IMPORTED_MODULE_2__["default"].textEntityMap.replace(item), data) : item.toChildren(data, filterFn);
    });
  },

  /*
    Transform content into string.
     @param content - array of UU5StringObjects, strings, numbers, booleans and UU5StringTemplates
    @param data - map with data for UU5String templates
    @param filterFn({tag, props}) - function to change tag and props used for printing into string. Function is called for each descendant UU5StringObject before print into string. This function cannot change data of UU5StringObjects.
    @returns string
  */
  contentToString: function contentToString(content, data, filterFn) {
    if (!content || !content.length) {
      return "";
    }

    if (typeof content === "string") {
      return Tools.printTemplateToString(content, data);
    }

    var result = "";
    content.forEach(function (item) {
      return result += typeof item === "string" ? Tools.printTemplateToString(item, data) : item.toString(data, filterFn);
    });
    return result;
  },
  printTemplateToString: function printTemplateToString(string, data) {
    if (!data) {
      return string;
    }

    var result = Tools._printTemplate(string, data);

    return result.length === 1 ? result[0] : result.join("");
  },
  printTemplateToChildren: function printTemplateToChildren(string, data) {
    if (!data) {
      return string;
    }

    var isChildren;

    var result = Tools._printTemplate(string, data, function (matchValue) {
      if (typeof matchValue === "string" && matchValue.match(_constants__WEBPACK_IMPORTED_MODULE_1__["UU5STRING_REGEXP"]) && Tools.isValidUU5String(matchValue)) {
        isChildren = true; // create component by _Tools.findComponent

        return Tools.parseUu5String(matchValue, Tools._buildReactComponent);
      }

      return matchValue;
    }); // result contains parsed UU5String - return array


    if (isChildren) return result;
    return result.length === 1 ? result[0] : result.join("");
  },
  _buildReactComponent: function _buildReactComponent(tag, propsString, children) {
    if (!tag) return children;
    var propsArray = propsString ? Tools.parseUU5StringProps(propsString, Tools._buildReactComponent) : [];
    var props = {};
    propsArray.forEach(function (item) {
      return props[item.name] = item.value;
    });
    return _uu5_common_tools_js__WEBPACK_IMPORTED_MODULE_3__["default"].findComponent(tag, props, children);
  },
  _printTemplate: function _printTemplate(string, data, matchHandler) {
    // check if string is single template - in this case return template result ( posible another type then string )
    // let isTemplate = string.match(CHECK_IS_TEMPLATE);
    var useMatchHandler = typeof matchHandler === "function";
    var result = [];
    var templateMatch = _constants__WEBPACK_IMPORTED_MODULE_1__["TEMPLATE_REG_EXP"].exec(string);
    var startIndex = 0;
    var endIndex = 0;
    /*
    template[1] - name
    template[2] - default value prefixed by :
    template[3] - default value
    */

    while (templateMatch) {
      var templateName = templateMatch[1];
      var value = void 0;
      endIndex = _constants__WEBPACK_IMPORTED_MODULE_1__["TEMPLATE_REG_EXP"].lastIndex - templateMatch[0].length;

      if (endIndex > startIndex) {
        result.push(string.substring(startIndex, endIndex));
      }

      startIndex = _constants__WEBPACK_IMPORTED_MODULE_1__["TEMPLATE_REG_EXP"].lastIndex;

      if (data[templateName]) {
        // check data
        var template = data[templateName];
        value = typeof template === "function" ? template() : template;
      } else if (_symbols__WEBPACK_IMPORTED_MODULE_0__["default"][templateName]) {
        // check symbols
        var _template = _symbols__WEBPACK_IMPORTED_MODULE_0__["default"][templateName];
        value = typeof _template === "function" ? _template() : _template;
      } else {
        // replace template by default value or empty string
        value = templateMatch[3] === undefined ? templateMatch[0] : templateMatch[3];
      }

      if (useMatchHandler) {
        var matchResult = matchHandler(value);

        if (Array.isArray(matchResult)) {
          matchResult.forEach(function (item) {
            return result.push(item);
          });
        } else {
          result.push(matchResult);
        }
      } else {
        result.push(value);
      }

      templateMatch = _constants__WEBPACK_IMPORTED_MODULE_1__["TEMPLATE_REG_EXP"].exec(string);
    } // add string after end of last match


    if (startIndex < string.length) {
      result.push(string.substring(startIndex));
    }

    return result;
  },
  isValidUU5String: function isValidUU5String(uu5string) {
    if (typeof uu5string !== "string") return false;

    try {
      Tools.parseUu5String(uu5string);
      return true;
    } catch (e) {
      return false;
    }
  },
  parseUu5String: function parseUu5String(uu5string, buildItem) {
    var parentParsingContext = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var issueReporter = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

    if (!uu5string || typeof uu5string !== "string" || uu5string.length === 0) {
      return [];
    }

    uu5string = uu5string.trim().replace(/\r\n/g, "\n");
    var tagsRegExp = _uu5_environment_js__WEBPACK_IMPORTED_MODULE_2__["default"].uu5StringTagsRegExp || null;
    var childStack = [{
      tag: "_root",
      children: [],
      index: 0
    }];
    var pointer = childStack[0];
    var cIndex = -1;
    var pIndex = 0;
    var pre = false;
    var parsingContext = {
      index: pIndex,
      string: uu5string,
      parentParsingContext: parentParsingContext
    };
    var matchS;
    var matchUu5String = uu5string.match(_constants__WEBPACK_IMPORTED_MODULE_1__["UU5STRING_REGEXP"]);

    if (matchUu5String) {
      // !!!!! Never put uu5stringRe to constants, otherwise it gets stuck - because of exec method on regexp
      // groups:
      //   comp name, attrs, -, -, -, -, -, -, self-closing, closing comp name
      //   invalid opening tag: comp name, partial attrs, -, -, -, -, -, -
      //   invalid closing tag: closing comp name
      var tagRe = new RegExp("".concat(_constants__WEBPACK_IMPORTED_MODULE_1__["TAG"], "|").concat(_constants__WEBPACK_IMPORTED_MODULE_1__["INVALID_OPENING_TAG"], "|").concat(_constants__WEBPACK_IMPORTED_MODULE_1__["INVALID_CLOSING_TAG"]), "g");
      pIndex = tagRe.lastIndex = matchUu5String[0].length;
      matchS = tagRe.exec(uu5string);

      var _loop = function _loop() {
        cIndex = matchS.index;

        if (cIndex > pIndex) {
          var head = uu5string.substring(pIndex, cIndex);
          var _text = head; // let text = pre ? Environment.textEntityMap.replaceHtmlEntity(head) : Environment.textEntityMap.replace(head);

          parsingContext.index = pIndex;
          pointer.children.push(typeof buildItem === "function" ? buildItem(null, null, _text, null, null, null, parsingContext) : _text);
        }

        var childTag = matchS[1] || matchS[9];
        var attrs = matchS[2];
        var isClosing = !!matchS[9];
        var isSelfClosing = !!matchS[8];
        var invalidOpeningTag = matchS[10]; // let invalidOpeningTagPartialAttrs = matchS[11];

        var invalidClosingTag = matchS[17];
        var isInvalid = !pre && (invalidOpeningTag || invalidClosingTag);
        var tagObj = void 0;

        if (pre && !(childTag === "uu5string.pre" && isClosing)) {
          var _text2 = matchS[0]; // TODO This is wrong (we could have matched something that looks like TAG which has </uu5string.pre> in its attribute - we should stop at that </uu5string.pre> whereas the current implementation will skip that and continue being in PRE).
          // let text = Environment.textEntityMap.replaceHtmlEntity(matchS[0]);

          parsingContext.index = cIndex;
          pointer.children.push(typeof buildItem === "function" ? buildItem(null, null, _text2, null, null, null, parsingContext) : _text2);
        } else if (isInvalid) {
          parsingContext.index = cIndex;

          if (issueReporter) {
            if (invalidOpeningTag) {
              issueReporter.warning("Parsing opening tag ".concat(invalidOpeningTag, " failed at position ").concat(cIndex + matchS[0].length, " - expected attribute or closing bracket."), _objectSpread({}, parsingContext, {
                index: cIndex + matchS[0].length
              }));
            } else if (invalidClosingTag) {
              issueReporter.warning("Parsing closing tag ".concat(invalidClosingTag, " failed at position ").concat(cIndex + matchS[0].length, " - expected closing bracket."), _objectSpread({}, parsingContext, {
                index: cIndex + matchS[0].length
              }));
            }
          }

          var _text3 = matchS[0].substr(0, 2); // use only first few characters from match and re-parse to be backward compatible (which is also why we handle this just as a warning instead of real error)


          pointer.children.push(typeof buildItem === "function" ? buildItem(null, null, _text3, null, null, null, parsingContext) : _text3);
          pIndex = cIndex + _text3.length;
          tagRe.lastIndex = pIndex;
          matchS = tagRe.exec(uu5string);
          return "continue";
        } else {
          if (isClosing) {
            //closing tag
            tagObj = childStack.pop();

            if (tagObj.tag !== childTag) {
              var _err;

              var isOpenSooner = childStack.some(function (parentTag) {
                return parentTag.tag === childTag;
              });

              if (isOpenSooner) {
                // can be either unclosed tag or wrong closing tag
                _err = new Error("Invalid uu5string: Tag ".concat(tagObj.tag, " at position ").concat(tagObj.index, " is not closed."));
                parsingContext.tag = tagObj.tag;
                parsingContext.index = tagObj.index;
              } else {
                // more likely to be wrong closing tag (or typo in opening tag)
                _err = new Error("Invalid uu5string: Tag ".concat(childTag, " at position ").concat(cIndex, " is not open.") + (childStack.length ? " Did you mean </".concat(tagObj.tag, ">?") : ""));
                parsingContext.tag = childTag;
                parsingContext.index = cIndex;
              }

              _err.code = "uu5StringInvalid";
              _err.context = parsingContext;
              _err.partialResult = (childStack[0] || pointer).children;
              throw _err;
            }

            pointer = childStack[childStack.length - 1];

            if (pre) {
              pre = false;

              var _text4 = tagObj.children.join(""); // let text = Environment.textEntityMap.replaceHtmlEntity(tagObj.children.join(''));


              parsingContext.index = tagObj.index;
              pointer.children[pointer.children.length - 1] = typeof buildItem === "function" ? buildItem(tagObj.tag, null, _text4, null, null, null, parsingContext) : _text4;
            } else {
              if (tagObj.forbidden) {
                tagObj.children = "Error: Tag <".concat(tagObj.tag, " /> is not allowed.");
                tagObj.tag = "Error";
              }

              parsingContext.index = tagObj.index;
              pointer.children[pointer.children.length - 1] = typeof buildItem === "function" ? buildItem(tagObj.tag, tagObj.attrs, tagObj.children, true, null, null, parsingContext) : tagObj;
            }
          } else {
            pre = childTag === "uu5string.pre";
            tagObj = {
              tag: childTag,
              children: [],
              index: matchS.index
            };
            if (tagsRegExp && !tagsRegExp.test(childTag)) tagObj.forbidden = true;else if (attrs) {
              tagObj.attrs = attrs;
            }

            if (isSelfClosing) {
              //self-closing tag
              pre = false;
              parsingContext.index = cIndex;

              if (childTag.indexOf("uu5string.") === 0) {
                //meta-tag uu5string.*
                var s = Tools.execMetaTag(childTag, tagObj.attrs);
                if (s) s.forEach(function (item) {
                  return pointer.children.push(typeof buildItem === "function" ? buildItem(null, null, item, null, null, null, parsingContext) : item);
                });
              } else {
                pointer.children.push(typeof buildItem === "function" ? buildItem(tagObj.tag, tagObj.attrs, tagObj.children, false, null, null, parsingContext) : tagObj);
              }
            } else {
              //common tag
              pointer.children.push(tagObj);
              childStack.push(tagObj);
              pointer = tagObj;
            }
          }
        }

        pIndex = cIndex + matchS[0].length;
        matchS = tagRe.exec(uu5string);
      };

      while (matchS) {
        var _ret = _loop();

        if (_ret === "continue") continue;
      } // handle ending text


      if (pIndex < uu5string.length) {
        var text = uu5string.substr(pIndex); // text = pre ? Environment.textEntityMap.replaceHtmlEntity(text) : Environment.textEntityMap.replace(text);

        parsingContext.index = pIndex;
        pointer.children.push(typeof buildItem === "function" ? buildItem(null, null, text, null, null, null, parsingContext) : text);
      }

      if (childStack.length > 1) {
        var tagObj = childStack.pop();
        var err = new Error("Invalid uu5string: Tag ".concat(tagObj.tag, " at position ").concat(tagObj.index, " is not closed."));
        err.code = "uu5StringInvalid";
        parsingContext.tag = tagObj.tag;
        parsingContext.index = tagObj.index;
        err.context = parsingContext;
        err.partialResult = (childStack[0] || pointer).children;
        throw err;
      }
    } else {
      parsingContext.index = pIndex;
      pointer.children.push(typeof buildItem === "function" ? buildItem(null, null, uu5string, null, null, null, parsingContext) : uu5string);
    }

    return pointer.children;
  },
  parseUU5StringProps: function parseUU5StringProps(attrsString, buildItem, buildAttr) {
    var parentParsingContext = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    var issueReporter = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
    var attrs = []; // group1 = separator
    // group2 = attribute name
    // group3 = name and value separator
    // group4 = attribute value
    // group5 = indication that attribute value is not wrapped into quotes / single quotes

    var attrsReg = new RegExp(_constants__WEBPACK_IMPORTED_MODULE_1__["ATTR_REGEXP"].source, "g");
    var matchAttrs = attrsReg.exec(attrsString);

    var _loop2 = function _loop2() {
      var separator = matchAttrs[1];
      var name = matchAttrs[2];
      var valueDelimiter = matchAttrs[3];
      var valueBoundaries = "";
      var value = true;
      var uu5DataKey = undefined;
      var valueType = null; // hold info if data is parsed from uu5string, uu5data or uu5json

      var matchValue = matchAttrs[4];
      var isUnquoted = !!matchAttrs[5];
      var revertToUnparsedValueFns = [];
      var matchValueIndex = matchAttrs.index + separator.length + name.length + (valueDelimiter || "").length;
      var parsingContext = {
        revertToUnparsedValueFns: revertToUnparsedValueFns,
        index: matchValueIndex,
        string: attrsString,
        parentParsingContext: parentParsingContext,
        prop: name,
        rawValue: matchValue
      };

      if (isUnquoted) {
        if (matchValue === "true") {
          //true
          value = true;
        } else if (matchValue === "false") {
          //false
          value = false;
        } else if (isFinite(matchValue)) {
          //number
          value = +matchValue;
        } else {
          //any other -> null
          value = null;
        }
      } else if (matchValue != null) {
        // unescape quoted value
        if (matchValue[0] === "'") {
          valueBoundaries = "'";
          matchValue = matchValue.substr(1, matchValue.length - 2).replace(/\\([\\'])/g, "$1");
          revertToUnparsedValueFns.push(function (input) {
            return valueBoundaries + input.replace(/(\\|')/g, "\\$1");
          });
        } else if (matchValue[0] === '"') {
          valueBoundaries = '"';
          matchValue = matchValue.substr(1, matchValue.length - 2).replace(/\\([\\"])/g, "$1");
          revertToUnparsedValueFns.push(function (input) {
            return valueBoundaries + input.replace(/(\\|")/g, "\\$1");
          });
        }

        var matchValueType = matchValue.match(_constants__WEBPACK_IMPORTED_MODULE_1__["ATTR_VALUE_TYPE_REGEXP"]);

        if (matchValueType[1]) {
          //uu5JSON
          valueType = "uu5json";
          value = _uu5_json_js__WEBPACK_IMPORTED_MODULE_5__["default"].parse(matchValue, null, parsingContext);
        } else if (matchValueType[2]) {
          //uu5String
          valueType = "uu5string";
          value = Tools.parseUu5String(matchValue, buildItem, parsingContext, issueReporter);
        } else if (matchValueType[3]) {
          //uu5Data
          valueType = "uu5data";
          var uu5DataKeyMatch = matchValue.match(_constants__WEBPACK_IMPORTED_MODULE_1__["UU5DATA_REGEXP"]);
          uu5DataKey = matchValue.replace(_constants__WEBPACK_IMPORTED_MODULE_1__["UU5DATA_REGEXP"], "");
          revertToUnparsedValueFns.push(function (input) {
            return uu5DataKeyMatch ? uu5DataKeyMatch[0] + input : input;
          });
          value = _uu5_data_js__WEBPACK_IMPORTED_MODULE_4__["default"].parse(matchValue, parsingContext);
        } else {
          //as-is
          if (name === "href") {
            var jsCodeMatch = matchValue.match(_constants__WEBPACK_IMPORTED_MODULE_1__["JSCODE_REGEXP"]);
            matchValue = matchValue.replace(_constants__WEBPACK_IMPORTED_MODULE_1__["JSCODE_REGEXP"], "");
            revertToUnparsedValueFns.push(function (input) {
              return jsCodeMatch ? jsCodeMatch[0] + input : input;
            });
          }

          value = matchValue;
        }
      }

      var attr = {
        name: name,
        value: value,
        valueDelimiter: valueDelimiter,
        separator: separator,
        valueBoundaries: valueBoundaries,
        valueType: valueType,
        uu5DataKey: uu5DataKey,
        rawValue: matchValue
      };
      if (typeof buildAttr === "function") attr = buildAttr(attr, parsingContext) || attr;
      attrs.push(attr);
      matchAttrs = attrsReg.exec(attrsString);
    };

    while (matchAttrs) {
      _loop2();
    }

    return attrs;
  },
  execMetaTag: function execMetaTag(tag, args) {
    //TODO implement each metaTag as separate function, call functions dynamically (witch safety keyword guard)
    var metaTag = tag.slice(10);
    var r = [];

    switch (metaTag) {
      case "now":
        r.push(_symbols__WEBPACK_IMPORTED_MODULE_0__["default"].now());
        break;

      case "codeHex32":
        r.push(_symbols__WEBPACK_IMPORTED_MODULE_0__["default"].idHex32());
        break;

      case "codeHex64":
        r.push(_symbols__WEBPACK_IMPORTED_MODULE_0__["default"].idHex64());
        break;

      default:
        r.push(null);
    }

    return r;
  },
  _escapeEntities: function _escapeEntities(text) {
    if (typeof text !== "string") return text; // TODO Maybe unescape emojis too.
    // NOTE Environment.textEntityMap doesn't have unescaping mechanism and it contains
    // multiple mappings to the same character, e.g. &lt; and &#060; are both mapped to ">".

    return text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
  }
};
/* harmony default export */ __webpack_exports__["default"] = (Tools);

/***/ }),
/* 7 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _uu5_common_tools_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8);

var SYMBOLS = {
  now: function now() {
    var date = new Date();
    return _uu5_common_tools_js__WEBPACK_IMPORTED_MODULE_0__["default"].toLocaleString(date, _uu5_common_tools_js__WEBPACK_IMPORTED_MODULE_0__["default"].getLanguage());
  },
  idHex32: function idHex32() {
    return _uu5_common_tools_js__WEBPACK_IMPORTED_MODULE_0__["default"].generateUUID(32);
  },
  idHex64: function idHex64() {
    return _uu5_common_tools_js__WEBPACK_IMPORTED_MODULE_0__["default"].generateUUID(64);
  }
};
/* harmony default export */ __webpack_exports__["default"] = (SYMBOLS);

/***/ }),
/* 8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "REGEXP", function() { return REGEXP; });
var REGEXP = {
  uu5string: /^\s*<uu5string\s*\/>/,
  uu5stringTemplate: /\${([0-9a-zA-Z.\-_]+)\s*(:\s*([0-9a-zA-Z.\-_ ()\[\]<>\\\/]+))?}/,
  uu5json: /^\s*<uu5json\s*\/>/,
  uu5data: /^\s*<uu5data\s*\/>/,
  jsCode: /^(javascript:\s*)*/i
};
var REGEXP_XY = /[xy]/g;
var Tools = {};

Tools.getLanguage = function () {
  return "en"; // Environment.languages[0] ? Environment.languages[0].location || Environment.languages[0].language : navigator.language;
};

Tools.toLocaleString = function (date, country, opt) {
  // because of IE
  return date.toLocaleString(country, opt).replace(/\u200E/g, "");
};

Tools.error = function (msg, context) {
  // if (Environment.isProduction()) {
  //   console.error('For debugging use development mode.');
  // } else {
  console.error(msg, context);
};

Tools.generateUUID = function (length) {
  length = Math.max(length, 8);
  var uuidCore = "x4xxxyxx";
  var additionalCharLength = length - uuidCore.length;

  for (var i = 0; i < additionalCharLength; ++i) {
    if (i % 2 === 0) uuidCore = uuidCore + "x";else uuidCore = "x" + uuidCore;
  }

  var timeNum = new Date().getTime();

  if (window.performance && typeof window.performance.now === "function") {
    timeNum += performance.now(); //use high-precision timer if available
  }

  return uuidCore.replace(REGEXP_XY, function (char) {
    var r = (timeNum + Math.random() * 16) % 16 | 0;
    timeNum = Math.floor(timeNum / 16);
    return (char === "x" ? r : r & 0x3 | 0x8).toString(16);
  });
};

/* harmony default export */ __webpack_exports__["default"] = (Tools);

/***/ }),
/* 9 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UU5STRING_REGEXP", function() { return UU5STRING_REGEXP; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UU5JSON_REGEXP", function() { return UU5JSON_REGEXP; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UU5DATA_REGEXP", function() { return UU5DATA_REGEXP; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "JSCODE_REGEXP", function() { return JSCODE_REGEXP; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "COMPONENT_NAME", function() { return COMPONENT_NAME; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ATTR", function() { return ATTR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TAG", function() { return TAG; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "INVALID_OPENING_TAG", function() { return INVALID_OPENING_TAG; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "INVALID_CLOSING_TAG", function() { return INVALID_CLOSING_TAG; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ATTR_REGEXP", function() { return ATTR_REGEXP; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ATTR_VALUE_TYPE_REGEXP", function() { return ATTR_VALUE_TYPE_REGEXP; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TEMPLATE_REG_EXP", function() { return TEMPLATE_REG_EXP; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CHECK_IS_TEMPLATE", function() { return CHECK_IS_TEMPLATE; });
/* harmony import */ var _uu5_common_tools_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8);
function _templateObject6() {
  var data = _taggedTemplateLiteral(["(", ")|(", ")|(", ")|"]);

  _templateObject6 = function _templateObject6() {
    return data;
  };

  return data;
}

function _templateObject5() {
  var data = _taggedTemplateLiteral(["</(", ")"]);

  _templateObject5 = function _templateObject5() {
    return data;
  };

  return data;
}

function _templateObject4() {
  var data = _taggedTemplateLiteral(["<(", ")((?:", ")*)"]);

  _templateObject4 = function _templateObject4() {
    return data;
  };

  return data;
}

function _templateObject3() {
  var data = _taggedTemplateLiteral(["<(", ")((?:", ")*)s*(/)?>|</(", ")>"], ["<(", ")((?:", ")*)\\s*(/)?>|</(", ")>"]);

  _templateObject3 = function _templateObject3() {
    return data;
  };

  return data;
}

function _templateObject2() {
  var data = _taggedTemplateLiteral(["(s+)([-w]+)(?:(s*=s*)(\"(?:\\.|[^\"\\])*\"|'(?:\\.|[^'\\])*'|([^\"'>s/][^>s/]*)))?"], ["(\\s+)([-\\w]+)(?:(\\s*=\\s*)(\"(?:\\\\.|[^\"\\\\])*\"|'(?:\\\\.|[^'\\\\])*'|([^\"'>\\s/][^>\\s/]*)))?"]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  var data = _taggedTemplateLiteral(["[-w.]+"], ["[-\\w.]+"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }


var UU5STRING_REGEXP = _uu5_common_tools_js__WEBPACK_IMPORTED_MODULE_0__["REGEXP"].uu5string;
var UU5JSON_REGEXP = _uu5_common_tools_js__WEBPACK_IMPORTED_MODULE_0__["REGEXP"].uu5json;
var UU5DATA_REGEXP = _uu5_common_tools_js__WEBPACK_IMPORTED_MODULE_0__["REGEXP"].uu5data;
var JSCODE_REGEXP = _uu5_common_tools_js__WEBPACK_IMPORTED_MODULE_0__["REGEXP"].jsCode;
var COMPONENT_NAME = String.raw(_templateObject()); // TODO Make stricter matching of unquoted attribute value, e.g. now it can be
// <X attr=\"value<uu5json/>{}"/> resulting in
// tag `X` with attr `attr` with value `\"value<uu5json` and ending as self-closing tag, followed by text `{}"/>`

var ATTR = String.raw(_templateObject2()); // groups: attr separator, attr name, value separator, attr value, indication whether without quotes

var TAG = String.raw(_templateObject3(), COMPONENT_NAME, ATTR, COMPONENT_NAME); // groups: comp name, attrs, -, -, -, -, -, -, self-closing, closing comp name

var INVALID_OPENING_TAG = String.raw(_templateObject4(), COMPONENT_NAME, ATTR); // groups: comp name, partial attrs, -, -, -, -, -, -

var INVALID_CLOSING_TAG = String.raw(_templateObject5(), COMPONENT_NAME); // groups: closing comp name

var ATTR_REGEXP = new RegExp(ATTR); // groups: see ATTR

var ATTR_VALUE_TYPE_REGEXP = new RegExp(String.raw(_templateObject6(), _uu5_common_tools_js__WEBPACK_IMPORTED_MODULE_0__["REGEXP"].uu5json.source, _uu5_common_tools_js__WEBPACK_IMPORTED_MODULE_0__["REGEXP"].uu5string.source, _uu5_common_tools_js__WEBPACK_IMPORTED_MODULE_0__["REGEXP"].uu5data.source)); // groups: uu5json, uu5string, uu5data

var TEMPLATE_REG_EXP = new RegExp(_uu5_common_tools_js__WEBPACK_IMPORTED_MODULE_0__["REGEXP"].uu5stringTemplate.source, "g");
var CHECK_IS_TEMPLATE = new RegExp("^".concat(_uu5_common_tools_js__WEBPACK_IMPORTED_MODULE_0__["REGEXP"].uu5stringTemplate.source, "$"));

/***/ }),
/* 10 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var Environment = {
  uu5DataMap: {},
  textEntityMap: {}
};
/* harmony default export */ __webpack_exports__["default"] = (Environment);

/***/ }),
/* 11 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UU5Data", function() { return UU5Data; });
/* harmony import */ var _uu5_environment_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10);
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9);
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }



var UU5Data = /*#__PURE__*/function () {
  function UU5Data() {
    _classCallCheck(this, UU5Data);
  }

  _createClass(UU5Data, null, [{
    key: "parse",
    value: function parse(uu5Data, parentParsingContext) {
      uu5Data = uu5Data.replace(_constants_js__WEBPACK_IMPORTED_MODULE_1__["UU5DATA_REGEXP"], "");
      var data = _uu5_environment_js__WEBPACK_IMPORTED_MODULE_0__["default"].uu5DataMap && _uu5_environment_js__WEBPACK_IMPORTED_MODULE_0__["default"].uu5DataMap[uu5Data];

      if (_typeof(data) === undefined) {
        console.warn("There is no component data in Environment.uu5DataMap for uu5Data: ".concat(uu5Data, " !"), {
          uu5Data: uu5Data
        });
      }

      return data;
    }
  }]);

  return UU5Data;
}();
/* harmony default export */ __webpack_exports__["default"] = (UU5Data);

/***/ }),
/* 12 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UU5Json", function() { return UU5Json; });
/* harmony import */ var _uu5_common_tools_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }


var UU5_JSON_REGEXP = /^\s*<uu5json\s*\/>/;
var UU5Json = /*#__PURE__*/function () {
  _createClass(UU5Json, null, [{
    key: "parse",
    value: function parse(uu5Json, onAttributeCallback, parentParsingContext) {
      var json = UU5Json.toJson(uu5Json);
      var value = null;

      try {
        value = JSON.parse(json);

        if (typeof onAttributeCallback === "function") {
          parseWithWalk(json, function (_ref) {
            var key = _ref.key,
                value = _ref.value,
                valueStartIndex = _ref.valueStartIndex,
                revertToUnparsedValueFns = _ref.revertToUnparsedValueFns;
            onAttributeCallback(key, value, {
              string: uu5Json,
              index: uu5Json.length - json.length + valueStartIndex,
              revertToUnparsedValueFns: revertToUnparsedValueFns,
              parentParsingContext: parentParsingContext
            });
          });
        }
      } catch (err) {
        if (!err.context) {
          _uu5_common_tools_js__WEBPACK_IMPORTED_MODULE_0__["default"].error("Error uu5JSON parse.", {
            uu5Json: json,
            cause: err
          });
          err.code = "uu5JsonInvalid";
          err.context = {
            json: json,
            index: uu5Json.length - json.length + Number((err.message.match(/position (\d+)/) || {})[1] || 0),
            string: uu5Json,
            parentParsingContext: parentParsingContext
          };
        }

        throw err;
      }

      return value;
    }
  }, {
    key: "toJson",
    value: function toJson(uu5Json) {
      return uu5Json.replace(UU5_JSON_REGEXP, "");
    }
  }]);

  function UU5Json(json) {
    _classCallCheck(this, UU5Json);

    this._uu5json = json;
    this._object = UU5Json.parse(json);
  }

  _createClass(UU5Json, [{
    key: "toUU5Json",
    value: function toUU5Json() {
      return this._uu5json;
    }
  }, {
    key: "toJson",
    value: function toJson() {
      return this._uu5json;
    }
  }, {
    key: "toObject",
    value: function toObject() {
      return this._object;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new UU5Json(this._uu5json);
    }
  }]);

  return UU5Json;
}();

function parseWithWalk(string, onAttribute) {
  // NOTE Assumes that string is valid JSON.
  // https://www.json.org/
  var index = skipWhitespace(string, 0);
  parseValue(string, index, "", onAttribute);
}

function parseValue(text, i, parentKey, onAttribute) {
  var startIndex = i;
  var m;

  if (text[i] === "{") {
    // object
    var obj = {};
    var first = true;
    ++i;

    while (true) {
      var hasComma = false;
      i = skipWhitespace(text, i);

      if (!first && text[i] !== "}") {
        if (text[i] === ",") {
          hasComma = true;
          i = skipWhitespace(text, i + 1);
        } else {
          throwError("Expected ',' or '}'", i, text);
        }
      } else {
        first = false;
      }

      if (text[i] === '"') {
        var _parseString = parseString(text, i),
            key = _parseString.value,
            index = _parseString.endIndex;

        index = skipWhitespace(text, index);
        if (text[index] !== ":") throwError("Expected ':'", index, text);
        index = skipWhitespace(text, index + 1);
        var fullKey = (parentKey ? parentKey + "." : "") + key;

        var _parseValue = parseValue(text, index, fullKey, onAttribute),
            value = _parseValue.value,
            valueStartIndex = _parseValue.startIndex,
            valueEndIndex = _parseValue.endIndex,
            revertToUnparsedValueFns = _parseValue.revertToUnparsedValueFns;

        onAttribute({
          key: fullKey,
          value: value,
          valueStartIndex: valueStartIndex,
          valueEndIndex: valueEndIndex,
          revertToUnparsedValueFns: revertToUnparsedValueFns
        });
        i = valueEndIndex;
        obj[key] = value;
      } else if (text[i] === "}") {
        if (hasComma) throwError("Expected '\"' due to previous comma", i, text);
        return {
          value: obj,
          startIndex: startIndex,
          endIndex: i + 1
        };
      } else {
        throwError("Expected '}' or '\"'", i, text);
      }
    }
  } else if (text[i] === "[") {
    // array
    var list = [];
    var _first = true;
    var arrayIndex = -1;
    ++i;

    while (true) {
      ++arrayIndex;
      var _hasComma = false;
      i = skipWhitespace(text, i);

      if (!_first && text[i] !== "]") {
        if (text[i] === ",") {
          _hasComma = true;
          i = skipWhitespace(text, i + 1);
        } else {
          throwError("Expected ',' or ']'", i, text);
        }
      } else {
        _first = false;
      }

      if (text[i] === "]") {
        if (_hasComma) throwError("Expected array item due to previous comma", i, text);
        return {
          value: list,
          startIndex: startIndex,
          endIndex: i + 1
        };
      } else {
        var _key = arrayIndex + "";

        var _fullKey = (parentKey ? parentKey + "." : "") + _key;

        var _parseValue2 = parseValue(text, i, _fullKey, onAttribute),
            _value = _parseValue2.value,
            _valueStartIndex = _parseValue2.startIndex,
            _valueEndIndex = _parseValue2.endIndex,
            _revertToUnparsedValueFns = _parseValue2.revertToUnparsedValueFns;

        onAttribute({
          key: _fullKey,
          value: _value,
          valueStartIndex: _valueStartIndex,
          valueEndIndex: _valueEndIndex,
          revertToUnparsedValueFns: _revertToUnparsedValueFns
        });
        i = _valueEndIndex;
        list.push(_value);
      }
    }
  } else if (text[i] === '"') {
    // string
    return parseString(text, i);
  } else if ((text[i] === "-" || text[i].match(/[0-9]/)) && (m = text.substr(i).match(/^-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE](?:[-+])?\d+)?/))) {
    // number
    return {
      value: Number(m[0]),
      startIndex: startIndex,
      endIndex: i + m[0].length
    };
  } else if (text.substr(i, 4) === "null") {
    return {
      value: null,
      startIndex: startIndex,
      endIndex: i + 4
    };
  } else if (text.substr(i, 4) === "true") {
    return {
      value: true,
      startIndex: startIndex,
      endIndex: i + 4
    };
  } else if (text.substr(i, 5) === "false") {
    return {
      value: false,
      startIndex: startIndex,
      endIndex: i + 5
    };
  } else {
    throwError("Expected object / array / string / number / true / false / null", i, text);
  }
}

function skipWhitespace(text, i) {
  var len = text.length;

  while (i < len && text[i].match(/\s/)) {
    ++i;
  }

  return i;
}

function parseString(text, i) {
  var unparsedValueArr = [];
  var startIndex = i;
  ++i;
  var len = text.length;
  var valueArr = [];

  while (i < len && text[i] !== '"') {
    if (text[i] === "\\") {
      var matched = false;
      text.substr(++i, 5).replace(/^["\\/bfnrt]|^u[a-fA-F0-9]{4}/, function (m) {
        matched = true;
        unparsedValueArr.push(text.substr(i - 1, 1 + m.length));
        i += m.length;
        if (m.length > 1) valueArr.push(String.fromCodePoint(Number("0x" + m.substr(1))));else if (m === "b") valueArr.push("\b");else if (m === "f") valueArr.push("\f");else if (m === "n") valueArr.push("\n");else if (m === "r") valueArr.push("\r");else if (m === "t") valueArr.push("\t");else valueArr.push(m);
      });
      if (!matched) throwError("Unsupported escape sequence", i - 1, text);
    } else {
      valueArr.push(text[i]);
      unparsedValueArr.push(text[i]);
      ++i;
    }
  }

  if (text[i] !== '"') throwError("Unterminated string literal starting", startIndex, text);
  var value = valueArr.join("");
  return {
    startIndex: startIndex,
    endIndex: i + 1,
    value: value,
    revertToUnparsedValueFns: [function (unescapedString) {
      if (!value.startsWith(unescapedString)) throw new Error("Cannot revert string to escaped form. The string was not parsed using context of this reversion function."); // NOTE Can't use regexp for escaping because backslash before "/" is optional and some characters
      // could have also been originally written using \uXXXX sequences.

      return '"' + unparsedValueArr.slice(0, unescapedString.length).join("");
    }]
  };
}

function throwError(msg, position, text) {
  throw new Error(msg + " @" + position + ":\n" + text.substr(position, 79));
}

/* harmony default export */ __webpack_exports__["default"] = (UU5Json);

/***/ }),
/* 13 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var IssueReporter = /*#__PURE__*/function () {
  function IssueReporter(_ref) {
    var aceErrorHandler = _ref.aceErrorHandler,
        aceDomBuilder = _ref.aceDomBuilder;

    _classCallCheck(this, IssueReporter);

    this.aceErrorHandler = aceErrorHandler;
    this.aceDomBuilder = aceDomBuilder;
  }

  _createClass(IssueReporter, [{
    key: "error",
    value: function error(message, context) {
      this._report("error", message, context);
    }
  }, {
    key: "warning",
    value: function warning(message, context) {
      this._report("warning", message, context);
    }
  }, {
    key: "_report",
    value: function _report(type, message, context) {
      var _ref2 = context || {},
          _ref2$index = _ref2.index,
          index = _ref2$index === void 0 ? 0 : _ref2$index,
          _ref2$string = _ref2.string,
          string = _ref2$string === void 0 ? "" : _ref2$string;

      var lines = string.substr(0, index).split(/\n/);
      var lineNumber = lines.length - 1;
      var columnNumber = lines[lines.length - 1].length;
      var usedMessage = message.replace(/position \d+/, "position " + columnNumber); // :-(
      // if (process.env.NODE_ENV !== "production" && (self.location.origin || "").startsWith("http://localhost:")) {
      //   let logLine = string.substr(0, index + 40).split(/\n/)[lineNumber];
      //   console.log(usedMessage + "\n" + logLine + "\n" + new Array(columnNumber).fill(" ").join("") + "^");
      // }

      this.aceDomBuilder.locator.lineNumber = lineNumber;
      this.aceDomBuilder.locator.columnNumber = columnNumber;
      this.aceErrorHandler[type](usedMessage);
    }
  }]);

  return IssueReporter;
}();

/* harmony default export */ __webpack_exports__["default"] = (IssueReporter);

/***/ })
/******/ ]);