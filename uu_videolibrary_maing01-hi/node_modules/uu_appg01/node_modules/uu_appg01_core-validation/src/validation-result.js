"use strict";

const DeepMerge = require("deepmerge");

/**
 * Object validation result
 */
class ValidationResult {
  constructor() {
    this.invalidTypes = {};
    this.invalidValues = {};
    this.missingKeys = {};
    this.invalidKeyMap = {};
    this.unsuportedKeys = [];
    this.childResults = {};
    this.valid = true;

    this.validationErrorMap = null;
  }

  /**
   * Checks if validation passed without any problems.
   * @returns {boolean}
   */
  isValid() {
    return this.valid;
  }

  /**
   * Adds error that value is of invalid base type.
   * @param {String} code
   * @param {String} message
   */
  addInvalidTypeError(code, message) {
    this.valid = false;
    this.invalidTypes[code] = message;
  }

  /**
   * Adds error that value is not valid.
   * @param {String} code
   * @param {String} message
   */
  addInvalidValueError(code, message) {
    this.valid = false;
    this.invalidValues[code] = message;
  }

  /**
   * Adds error that key is not valid.
   * @param {String} code
   * @param {String} message
   */
  addInvalidKeyError(code, message) {
    this.valid = false;
    this.invalidKeyMap[code] = message;
  }

  /**
   * Adds key which is not declared in type definition.
   * @param {String} key
   */
  addUnsupportedKey(key) {
    this.unsuportedKeys.push(key);
  }

  /**
   * Adds error that required value is missing.
   * @param {String} code
   * @param {String} message
   */
  addMissingKey(code, message) {
    this.valid = false;
    this.missingKeys[code] = message;
  }

  /**
   * Adds validation result of nested object.
   * @param {String} key
   * @param {Object} result
   */
  addChildResult(key, result) {
    if (result.valid == null) {
      result = result.result;
    }
    if (this.childResults[key]) {
      this.childResults[key].invalidKeyMap = DeepMerge(this.childResults[key].invalidKeyMap, result.invalidKeyMap);
      this.childResults[key].invalidTypes = DeepMerge(this.childResults[key].invalidTypes, result.invalidTypes);
      this.childResults[key].invalidValues = DeepMerge(this.childResults[key].invalidValues, result.invalidValues);
      this.childResults[key].missingKeys = DeepMerge(this.childResults[key].missingKeys, result.missingKeys);
      this.childResults[key].unsupportedKeyList = this.childResults[key].unsuportedKeys.concat(result.unsuportedKeys);
      this.childResults[key].valid = this.childResults[key].valid === false ? false : result.valid;
    } else {
      this.childResults[key] = result;
    }
    this.valid = this.valid && result.valid;
  }

  /**
   * Returns set of keys which were required, but were not.
   * @returns {Array}
   */
  getMissingKeys() {
    if (!this.validationErrorMap) {
      this.getValidationErrorMap();
    }
    if (this.validationErrorMap.missingKeyMap) {
      return Object.keys(this.validationErrorMap.missingKeyMap);
    } else {
      return [];
    }
  }

  /**
   * Returns set of keys which refers to values not matching expected.
   * @returns {Array}
   */
  getInvalidValueKeys() {
    if (!this.validationErrorMap) {
      this.getValidationErrorMap();
    }
    if (this.validationErrorMap.invalidValueKeyMap) {
      return Object.keys(this.validationErrorMap.invalidValueKeyMap);
    } else {
      return [];
    }
  }

  /**
   * Returns set of keys which refers to values of invalid base type.
   * @returns {Array}
   */
  getInvalidTypeKeys() {
    if (!this.validationErrorMap) {
      this.getValidationErrorMap();
    }
    if (this.validationErrorMap.invalidTypeKeyMap) {
      return Object.keys(this.validationErrorMap.invalidTypeKeyMap);
    } else {
      return [];
    }
  }

  /**
   * Returns set of keys which are unknown according to type definition.
   * @returns {Array}
   */
  getUnsupportedKeys() {
    if (!this.validationErrorMap) {
      this.getValidationErrorMap();
    }
    if (this.validationErrorMap.unsupportedKeyList) {
      return this.validationErrorMap.unsupportedKeyList;
    } else {
      return [];
    }
  }

  /**
   * Returns set of keys whose validation resulted in one of given.
   * @returns {Array}
   */
  getInvalidAttributeKeys() {
    if (!this.validationErrorMap) {
      this.getValidationErrorMap();
    }
    if (this.validationErrorMap) {
      let result = [];
      let keys = Object.keys(this.validationErrorMap);
      keys.forEach(key => {
        if (Array.isArray(this.validationErrorMap[key]) || this.validationErrorMap[key] instanceof Array) {
          result = result.concat(this.validationErrorMap[key]);
        } else {
          result = result.concat(Object.keys(this.validationErrorMap[key]));
        }
      });
      return result;
    } else {
      return [];
    }
  }

  /**
   * Returns nested validation result.
   * @param rootString
   * @returns {Object}
   */
  getValidationResult(rootString) {
    rootString = rootString.split(/\]\[|\]\.|\[|\]|\./);
    if (rootString[0] === "$") {
      rootString.shift();
    }

    return this._pathToValue(rootString);
  }

  _pathToValue(parts) {
    let value = this;
    parts.forEach(val => {
      if (val !== "") {
        value = value.childResults[val];
      }
    });

    return value;
  }

  /**
   * Transforms validation result into Hash which can be used e.g. as part
   * @param rootString
   * @returns {{invalidValueKeyMap: {}, invalidTypeKeyMap: {}, invalidKeyMap: {}, missingKeyMap: {}, unsupportedKeyList: Array}}
   */
  getValidationErrorMap(rootString) {
    let result;

    if (rootString) {
      let validationResult = this.getValidationResult(rootString);
      result = this._getInvalidErrorMap("$", validationResult);
    } else {
      result = this._getInvalidErrorMap("$");
    }

    if (Object.keys(result.invalidValueKeyMap).length === 0) {
      delete result.invalidValueKeyMap;
    }
    if (Object.keys(result.invalidTypeKeyMap).length === 0) {
      delete result.invalidTypeKeyMap;
    }
    if (Object.keys(result.invalidKeyMap).length === 0) {
      delete result.invalidKeyMap;
    }
    if (Object.keys(result.missingKeyMap).length === 0) {
      delete result.missingKeyMap;
    }
    if (result.unsupportedKeyList.length === 0) {
      delete result.unsupportedKeyList;
    }

    this.validationErrorMap = result;
    return result;
  }

  /**
   *
   * @param prefix
   * @param root
   * @returns {{invalidValueKeyMap: {}, invalidTypeKeyMap: {}, invalidKeyMap: {}, missingKeyMap: {}, unsupportedKeyList: Array}}
   * @private
   */
  _getInvalidErrorMap(prefix, root = this) {
    root.prefix = prefix;

    let result = {
      invalidValueKeyMap: {},
      invalidTypeKeyMap: {},
      invalidKeyMap: {},
      missingKeyMap: {},
      unsupportedKeyList: []
    };

    result.invalidValueKeyMap[prefix] = {};
    result.invalidTypeKeyMap[prefix] = {};
    result.invalidKeyMap[prefix] = {};
    result.missingKeyMap[prefix] = {};
    result.unsupportedKeyList = [];

    if (Object.keys(root.invalidValues).length !== 0) {
      Object.assign(result.invalidValueKeyMap[prefix], root.invalidValues);
    }
    if (Object.keys(result.invalidValueKeyMap[prefix]).length === 0) {
      delete result.invalidValueKeyMap[prefix];
    }

    if (Object.keys(root.invalidTypes).length !== 0) {
      Object.assign(result.invalidTypeKeyMap[prefix], root.invalidTypes);
    }
    if (Object.keys(result.invalidTypeKeyMap[prefix]).length === 0) {
      delete result.invalidTypeKeyMap[prefix];
    }

    if (Object.keys(root.invalidKeyMap).length !== 0) {
      Object.assign(result.invalidKeyMap[prefix], root.invalidKeyMap);
    }
    if (Object.keys(result.invalidKeyMap[prefix]).length === 0) {
      delete result.invalidKeyMap[prefix];
    }

    if (Object.keys(root.missingKeys).length !== 0) {
      Object.assign(result.missingKeyMap[prefix], root.missingKeys);
    }
    if (Object.keys(result.missingKeyMap[prefix]).length === 0) {
      delete result.missingKeyMap[prefix];
    }

    if (root.unsuportedKeys.length > 0) {
      root.unsuportedKeys.forEach(unsupKey => {
        if (!prefix) {
          prefix = "$";
        }
        result.unsupportedKeyList.push(`${prefix}.${unsupKey}`);
      });
    }

    let ChildrenResultKeys = Object.keys(root.childResults);
    ChildrenResultKeys.forEach(childdrenKey => {
      let children = root.childResults[childdrenKey];

      if (childdrenKey.match(/^[0-9]+$/)) {
        childdrenKey = `[${childdrenKey}]`;
      } else {
        childdrenKey = `.${childdrenKey}`;
      }

      let prefix = `${root.prefix}${childdrenKey}`;
      let tmp;
      if ("_getInvalidErrorMap" in children) {
        tmp = children._getInvalidErrorMap(prefix);
      } else {
        let a = 2;
      }
      if (tmp) {
        Object.assign(result.invalidValueKeyMap, tmp.invalidValueKeyMap);
        Object.assign(result.invalidTypeKeyMap, tmp.invalidTypeKeyMap);
        Object.assign(result.invalidKeyMap, tmp.invalidKeyMap);
        Object.assign(result.missingKeyMap, tmp.missingKeyMap);

        result.unsupportedKeyList = result.unsupportedKeyList.concat(tmp.unsupportedKeyList);
      }
    });

    return result;
  }
}

module.exports = ValidationResult;
