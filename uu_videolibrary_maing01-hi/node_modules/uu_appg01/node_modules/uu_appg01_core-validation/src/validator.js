"use strict";

const Parser = require("./parser.js");
const MatcherStore = require("./matcher-store.js");
const ValidationResult = require("./validation-result.js");
const LOAD_ALL = "loadAll";

let globalValidator;

/**
 * Main component for validations handling
 */
class Validator {
  /**
   * Returns new instance of Validator
   * @param {String} schema - path to file or whole schema in string form
   */
  constructor(schema) {
    if (isNode() && schema) {
      if (schema === LOAD_ALL) {
        schema = this._loadAllSchemas();
      } else {
        schema = this._loadFromFile(schema);
      }
    } else {
      this._loadMatchers();
    }
    if (schema) {
      this._parseSchema(schema);
    }
  }

  /**
   * Returns instance of Validator with loaded all validation types.
   * @param reload Forces reloading of schemes, defaults to false
   * @return {Validator}
   */
  static load(reload = false) {
    if (!globalValidator || reload) {
      globalValidator = new Validator(LOAD_ALL);
    }
    return globalValidator;
  }

  /**
   * process internal validation
   * @param {Object} value
   * @param {Object} ctx
   * @param {Object} result
   * @param {Object} chainObject
   * @returns {*}
   * @private
   */
  _validateInternal(value, ctx, result, chainObject) {
    let validator = chainObject.validator;
    let args = chainObject.args;
    validator.matchers.forEach(matcher => {
      Object.assign(result, matcher.match(value, ctx, this.validatorMap).result);
    });

    return result;
  }

  /**
   * load matchers from matcher store
   * @private
   */
  _loadMatchers() {
    let keys = Object.keys(MatcherStore.matchers);
    keys.forEach(key => {
      this[key] = MatcherStore.matchers[key];
    });
  }

  /**
   * Start the process of validation
   * @param {String} type Validation type name
   * @param {Object} value Value to validate again schema
   * @returns {ValidationResult}
   */
  validate(type, value) {
    let result = new ValidationResult();
    if (this.validationTypes == null || this.validationTypes[type] == null) {
      throw new Error(`Validation type ${type} not found.`);
    }

    let chain = { validator: this.validationTypes[type], args: value };

    let ctx = {};
    ctx["initialValue"] = value;
    ctx["parentValue"] = value;
    this.values = value;
    this.validatorMap = {};

    this._iterate(this.validationTypes[type]);

    let finalResult = this._validateInternal(value, ctx, result, chain);
    finalResult._schema = {};
    finalResult._schema.string = this.schema;
    finalResult._schema.name = type;

    return finalResult;
  }

  /**
   * iterate over the schema
   * @param obj
   * @private
   */
  _iterate(obj) {
    let objs = obj.matchers[0].params[0];
    if (objs != null) {
      let keys = Object.keys(objs);
      keys.forEach(key => {
        this.validatorMap[key] = objs[key];
      });
    }
  }

  /**
   * Parse schema from string form
   * @param schemaString
   * @private
   */
  _parseSchema(schemaString) {
    this.schema = schemaString;
    this.validationTypes = Parser.parse(schemaString);
  }

  _loadAllSchemas() {
    const { Config, Finder } = require("uu_appg01_core-utils");

    let loadedSchemas = "";
    let rootPath = Config.get("server_root") || process.cwd();
    let schemaPattern = "{src,app,src/api,app/api,}/validation_types/*.js";

    let moduleSchemaPaths = Finder.findInModules(rootPath, schemaPattern).sort(
      (a, b) => (a.split(/[\\/]/).pop() > b.split(/[\\/]/).pop()) ? 1 : -1
    );
    for (let schemaPath of moduleSchemaPaths) {
      let schemaContent = this._loadFromFile(schemaPath);
      loadedSchemas += schemaContent + "\n";
    }

    let projectSchemaPaths = Finder.findInProject(rootPath, schemaPattern).sort(
      (a, b) => (a.split(/[\\/]/).pop() > b.split(/[\\/]/).pop()) ? 1 : -1
    );
    for (let schemaPath of projectSchemaPaths) {
      let schemaContent = this._loadFromFile(schemaPath);
      loadedSchemas += schemaContent + "\n";
    }

    return loadedSchemas;
  }

  /**
   * Load schema definitions from file
   * @param  {String} schemaPath
   * @returns {String}
   * @private
   */
  _loadFromFile(schemaPath) {
    const Recast = require("recast");
    const Path = require("path");
    const Fs = require("fs");

    let file = Path.resolve(__dirname, schemaPath);

    if (!Fs.existsSync(schemaPath)) {
      return schemaPath;
    }

    let code = Fs.readFileSync(file).toString();
    let ast = Recast.parse(code);
    return Recast.print(ast).code;
  }
}

let isNode = new Function("try {return this===global;}catch(e){return false;}");

module.exports = Validator;
