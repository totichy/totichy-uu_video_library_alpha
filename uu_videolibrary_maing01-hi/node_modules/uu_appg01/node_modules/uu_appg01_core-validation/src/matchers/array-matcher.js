"use strict";

const Matcher = require("../matcher");
const ValidationResult = require("../validation-result");
const Validator = require("../validator");

class _Array extends Matcher {
  constructor(...params) {
    super("array");
    this.params = params;
  }

  match(value, ctx, ...args) {
    this.result = new ValidationResult();

    if (value == undefined) {
      return this;
    }

    let arg = this.params;

    let validator;
    let minSize;
    let maxSize;

    if (!(Object.prototype.toString.call(value) == "[object Array]")) {
      this.result.addInvalidTypeError("array.e001", "The value must be array.");
    } else {
      if (arg === undefined || arg.length === 0) {
        [validator, minSize, maxSize] = [undefined, undefined, undefined];
      } else if (arg.length === 1) {
        [validator, minSize, maxSize] = [arg[0], undefined, undefined];
      } else if (arg.length === 2) {
        [validator, minSize, maxSize] = [arg[0], undefined, arg[1]];
      } else {
        [validator, minSize, maxSize] = [arg[0], arg[1], arg[2]];
      }

      if (validator) {
        let arrayCtx = {...ctx};
        arrayCtx.parentValue = value;
        let index = 0;
        value.forEach(val => {
          validator.matchers.forEach(matcher => {
            let childResult = matcher.match(val, arrayCtx, matcher.params[0]);
            if (childResult.result) {
              this.result.addChildResult(index, childResult.result);
            } else {
              this.result.addChildResult(index, childResult);
            }
          });
          index += 1;
        });
        if (!this.result.valid) {
          this.result.addInvalidValueError("array.e002", `The value must be array of ${validator.matchers[0].name}.`);
        }
      }

      if (minSize && value.length < minSize) {
        this.result.addInvalidValueError("array.e003", `The array must have at least ${minSize} elements.`);
      } else if (maxSize && value.length > maxSize) {
        this.result.addInvalidValueError("array.e004", `The array size must not exceed ${maxSize} elements.`);
      }
    }

    return this;
  }
}

function ArrayMatcher(...params) {
  let matcher = new _Array(...params);
  if (this && this && this.matchers && this.matchers[0]) {
    this.matchers.push(matcher);
    return this;
  } else {
    let validator = new Validator(null);
    validator._loadMatchers();
    validator.matchers = [matcher];
    return validator;
  }
}

module.exports = ArrayMatcher;
