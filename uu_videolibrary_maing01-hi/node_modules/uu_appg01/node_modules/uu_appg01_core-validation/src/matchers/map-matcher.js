"use strict";

const Matcher = require("../matcher");
const ValidationResult = require("../validation-result");
const Validator = require("../validator");

class _Map extends Matcher {
  constructor(...params) {
    super("map");
    this.params = params;
  }

  match(value, ctx, keyValidator = undefined, valueValidator = undefined, minSize = undefined, maxSize = undefined) {
    this.result = new ValidationResult();

    if (value == undefined) {
      return this;
    }

    keyValidator = this.params[0];
    valueValidator = this.params[1];
    minSize = this.params[2];
    maxSize = this.params[3];

    if (typeof value !== "object") {
      this.result.addInvalidTypeError("map.e001", "The value must be a map.");
    } else {
      if (keyValidator && valueValidator && maxSize === undefined) {
        [minSize, maxSize] = [undefined, minSize];
      }
      if (typeof keyValidator === "integer" && typeof valueValidator === "integer") {
        [keyValidator, valueValidator, minSize, maxSize] = [undefined, undefined, keyValidator, valueValidator];
      }
      if (typeof keyValidator === "integer" && valueValidator === undefined) {
        [keyValidator, valueValidator, minSize, maxSize] = [undefined, undefined, undefined, keyValidator];
      }

      if (keyValidator) {
        ctx["parentValue"] = value;

        let keys = Object.keys(value);
        let keyIndex = 0;
        keys.forEach(key => {
          let val = value[key];
          let childResult = new ValidationResult();

          let keyValResult = new ValidationResult();

          let matchereRes = new ValidationResult();
          keyValidator.matchers.forEach(matcher => {
            keyValResult.addChildResult(key, matcher.match(key, ctx).result);
          });

          if (!keyValResult.valid) {
            let keyValResErrorMap = keyValResult.getValidationErrorMap();
            let keyValResKeys = Object.keys(keyValResErrorMap);
            keyValResKeys.forEach(key => {
              let invalidMap = keyValResErrorMap[key];
              let invalidMapKeys = Object.keys(invalidMap);
              invalidMapKeys.forEach(invalidKey => {
                childResult.addInvalidKeyError(
                  Object.keys(invalidMap[invalidKey])[0],
                  Object.values(invalidMap[invalidKey])[0]
                );
              });
            });
          }

          let ValueValResult = new ValidationResult();
          let index = 0;
          valueValidator.matchers.forEach(matcher => {
            ValueValResult.addChildResult(key, matcher.match(val, ctx, matcher.params[index]));
            index += 1;
          });

          if (Object.keys(childResult.invalidKeyMap).length !== 0) {
            ValueValResult.childResults[key].invalidKeyMap = childResult.invalidKeyMap;
            ValueValResult.childResults[key].valid = false;
          }
          this.result.addChildResult(key, ValueValResult.childResults[key]);
          keyIndex += 1;
        });
      }

      if (!this.result.valid) {
        this.result.addInvalidValueError("map.e002", "The content of map must be valid.");
      }

      let size = Object.keys(value).length;
      if (minSize && minSize > size) {
        this.result.addInvalidValueError("map.e004", `The map must not contain less then ${minSize} entries.`);
      }
      if (maxSize && maxSize < size) {
        this.result.addInvalidValueError("map.e004", `The map must not contain more then ${maxSize} entries.`);
      }
    }

    return this;
  }
}

function MapMatcher(...params) {
  let matcher = new _Map(...params);
  if (this && this.matchers && this.matchers[0]) {
    this.matchers.push(matcher);
    return this;
  } else {
    let validator = new Validator(null);
    validator._loadMatchers();
    validator.matchers = [matcher];
    return validator;
  }
}

module.exports = MapMatcher;
