import UU5 from "uu5g04";
import Cfg from "../../config/config.js";
import Image from "../image.js";
import Tools, { REGEXP } from "./tools.js";

export const ThumbnailListBody = UU5.Common.VisualComponent.create({
  //@@viewOn:mixins
  mixins: [UU5.Common.BaseMixin, UU5.Common.ElementaryMixin],
  //@@viewOff:mixins

  //@@viewOn:statics
  statics: {
    tagName: Cfg.TAG + "ThumbnailListBody",
    classNames: {
      main: Cfg.CSS + "thumbnail-list-body",
      mode: Cfg.CSS + "thumbnail-list-mode-", // not called thumbnail-list-body... for backward compatibility
      placeholder: Cfg.CSS + "thumbnail-list-body-placeholder"
    },
    defaults: {
      padding: 2
    },
    imageCache: {}
  },
  //@@viewOff:statics

  //@@viewOn:propTypes
  propTypes: {
    path: UU5.PropTypes.string,
    data: UU5.PropTypes.arrayOf(
      UU5.PropTypes.oneOfType([
        UU5.PropTypes.string,
        UU5.PropTypes.shape({
          src: UU5.PropTypes.string.isRequired,
          thumb: UU5.PropTypes.string,
          alt: UU5.PropTypes.string
        })
      ])
    ).isRequired,
    mode: UU5.PropTypes.oneOf(["default", "track"]),
    colWidth: UU5.PropTypes.string,
    shape: UU5.PropTypes.string,
    effect: UU5.PropTypes.string,
    thumbSuffix: UU5.PropTypes.string,
    lightbox: UU5.PropTypes.oneOf(["local", "global", "none"]),
    rowMaxHeight: UU5.PropTypes.number,
    rowMinHeight: UU5.PropTypes.number,
    lastRowMaxHeight: UU5.PropTypes.number,
    rowWidth: UU5.PropTypes.number,
    session: UU5.PropTypes.object
  },
  //@@viewOff:propTypes

  //@@viewOn:getDefaultProps
  getDefaultProps() {
    return {
      path: "",
      data: [],
      mode: "default",
      colWidth: "xs-6 s-3 m-2 l-1 xl-1",
      shape: undefined,
      effect: undefined,
      thumbSuffix: "_th",
      lightbox: "local",
      rowMaxHeight: 160,
      rowMinHeight: 100,
      lastRowMaxHeight: undefined,
      rowWidth: undefined,
      session: undefined
    };
  },
  //@@viewOff:getDefaultProps

  //@@viewOn:reactLifeCycle
  getInitialState() {
    if (this.props.globalLightbox !== undefined) {
      UU5.Common.Tools.warning('Property "globalLightbox" is deprecated! Use "globalLightbox" property instead.');
    }

    return {
      index: 0,
      imgList: [],
      pendingLoadCount: this.props.data.length,
      boundingRect: null
    };
  },

  componentDidMount() {
    this.props.data.length > 0 && this._loadImages();
  },

  componentWillReceiveProps(nextProps) {
    if (nextProps.controlled && !UU5.Common.Tools.deepEqual(this.props.data, nextProps.data)) {
      this._loadImages(nextProps);
    }
  },
  //@@viewOff:reactLifeCycle

  //@@viewOn:interface
  //@@viewOff:interface

  //@@viewOn:overridingMethods
  //@@viewOff:overridingMethods

  //@@viewOn:private
  async _loadImages(props = this.props) {
    this._dataChangeId = Math.random();
    let imgList = [];
    let dataChangeId = this._dataChangeId;
    let pendingLoadCount = props.data.length;

    for (let i = 0; i < props.data.length; i++) {
      const image = await this._loadImage(props.data[i], props.authenticate, props.session);

      if (dataChangeId !== this._dataChangeId) return;

      pendingLoadCount--;
      if (image) imgList.push(image);
      this.setAsyncState({ imgList, pendingLoadCount });
    }

    this.setAsyncState({ imgList, pendingLoadCount });
  },

  _loadImage(imageData, authenticate, session) {
    if (typeof imageData === "string") {
      imageData = { src: imageData };
    }

    if (this.props.path) {
      imageData.src = this.props.path + imageData.src;

      if (imageData.thumb) {
        imageData.thumb = this.props.path + imageData.thumb;
      }
    }

    let thumbUrl = imageData.thumb || this._getThumbnail(imageData.src);
    let cacheMatch = this.constructor.imageCache[thumbUrl];
    let result;

    if (cacheMatch) {
      result = cacheMatch;
    } else {
      if (authenticate) {
        session = session || UU5.Environment.getSession();
        if (session && session.isAuthenticated() && UU5.Environment.isTrustedDomain(thumbUrl)) {
          result = new Promise(resolve => {
            let result = { ...imageData };
            Tools.fetchAuthenticatedImage(thumbUrl, session).then(
              data => {
                result.thumb = URL.createObjectURL(data.data);
                resolve(this._getImageData(result, thumbUrl));
              },
              err => {
                Tools.fetchAuthenticatedImage(imageData.src, session).then(
                  data => {
                    result.thumb = URL.createObjectURL(data.data);
                    resolve(this._getImageData(result, imageData.src));
                  },
                  err => {
                    result.thumb = "data:image/gif;base64,ZZZZZZZZ"; // invalid image
                    resolve(this._getImageData(result, thumbUrl));
                  }
                );
              }
            );
          });
        }
      }
    }

    if (!result) {
      result = this._getImageData(imageData, thumbUrl);
    }

    return result;
  },

  _getImageData(imageData, cacheKey) {
    return new Promise(resolve => {
      let lightboxSrc;
      let thumb;

      if (imageData && typeof imageData === "object") {
        lightboxSrc = imageData.src;
        thumb = imageData.thumb || imageData.lightboxSrc;
      } else {
        lightboxSrc = imageData;
      }

      thumb = thumb || this._getThumbnail(lightboxSrc);

      let img = new window.Image();
      let loadingThumbnail = true;

      img.onload = () => {
        let imgObj = {
          lightboxSrc,
          thumb: loadingThumbnail ? thumb : lightboxSrc,
          width: img.width,
          height: img.height,
          alt: imageData.alt || ""
        };

        this.constructor.imageCache[cacheKey] = imgObj;

        resolve(imgObj);
      };

      img.onerror = () => {
        if (loadingThumbnail) {
          loadingThumbnail = false;
          img.src = lightboxSrc;
          img.alt = imageData.alt || "";
          return;
        }

        resolve(null);
      };

      img.src = thumb;
    });
  },

  _getThumbnail(name) {
    let thumbnail;
    let dotIndex = name.lastIndexOf(".");

    if (dotIndex !== -1) {
      let fileName = name.substr(0, dotIndex);
      let fileExtension = name.substr(dotIndex + 1);
      if (REGEXP.fileExtension.test(fileExtension)) {
        thumbnail = fileName + this.props.thumbSuffix + "." + fileExtension;
      }
    }

    if (!thumbnail) {
      thumbnail = name + this.props.thumbSuffix;
    }

    return thumbnail;
  },

  _getLightbox() {
    if (this.props.lightbox === "global") {
      return null;
    } else if (this.props.lightbox === "none") {
      return false;
    } else if (this.props.globalLightbox === true) {
      // backward compatibility (deprecated prop)
      return null;
    } else {
      return this.getId();
    }
  },

  _getRowItems(data, width) {
    let separator = this.getDefault().padding * 2;
    width = width - (data.length - 1) * separator;
    let height = data.reduce((sum, x) => {
      return sum + (x.width * 1.0) / x.height;
    }, 0);
    return width / height;
  },

  _setHeight(data, rowIndex, height, aWidth) {
    let row = [];
    let width = aWidth;
    if (data.length === 1) {
      row.push({
        lightboxSrc: data[0].lightboxSrc,
        thumb: data[0].thumb,
        alt: data[0].alt,
        caption: data[0].caption,
        width: Math.min(width, (height * data[0].width) / data[0].height),
        height: height,
        column: 0,
        row: rowIndex,
        placeholder: data[0].placeholder
      });
    } else {
      for (let i = 0; i < data.length; i++) {
        row.push({
          column: i,
          row: rowIndex,
          lightboxSrc: data[i].lightboxSrc,
          thumb: data[i].thumb,
          caption: data[i].caption,
          alt: data[i].alt,
          width: (height * data[i].width) / data[i].height,
          height: height,
          left: i === 0 ? 0 : this.getDefault().padding,
          right: i === data.length - 1 ? 0 : this.getDefault().padding,
          placeholder: data[i].placeholder
        });
      }
    }

    return row;
  },

  _getTrackGrid(data, width, rowMaxHeight, rowMinHeight, lastRowMaxHeight, pendingLoadCount) {
    // Algorithm for distributing images into rows is split into 1st pass and optional 2nd pass:
    // - 1st pass - we're trying to distribute images into width W:
    //   - take AS FEW of images so that they can be fit into width W while having same height and the height is <= rowMaxHeight
    //     (preserving their aspect ratio)
    //     => how to compute the height of used images while fitting them into width W:
    //       - choose height H0 arbitrarily; scale each of images individually (preserve aspect ratio) such that they all have the height H0
    //       - after scaling, sum up their widths (W0); W0=sum(H0*imageWidth/imageHeight)
    //       - now they all have height H0, their width sum is W0 and we want to fit them into width W, so scale all of them
    //         by W/W0 factor and find out their final height H; H = H0*W/W0 = H0*W/sum(H0*imageWidth/imageHeight) = W/sum(imageWidth/imageHeight)
    //       - and that is what _getRowItems(images, W) does (with addition of handling paddings between images)
    //   - we now have 1 row of images, we want them to be at least rowMinHeight high:
    //     - if they are not and it's just 1 image then let it be that way (its width/height aspect ratio is very big)
    //     - if they are not and it's more images then drop (unprocess) the last added one and recompute height - this will
    //       actually result in used images having height > rowMaxHeight (but that's ok - it's better than having tiny row)
    //   - continue the algorithm from the start using remaining images
    //   - if there're no remaining images and the row has height > rowMaxHeight then continue with 2nd pass; otherwise end (all rows are width-aligned)
    // - 2nd pass tries to distribute images from unaligned/too high last row into previous rows:
    //   1. start from last row, going backwards; images in last row are "extras"
    //   2. move all "extras" onto the end of previous row; this will make the previous row's height smaller
    //   3. if the row height >= rowMinHeight then end (all rows are now width-aligned)
    //   4. otherwise remove as few of images from the start of the row so that the remaining images in the row
    //      compute to height >= rowMinHeight (the row becomes higher by removing images); removed images will become new "extras"
    //   5. repeat from step 2 (if there's still a previous row), otherwise 2nd pass failed and continue with next step
    //   6. use rows as computed by 1st pass (last row height is now > rowMaxHeight)
    //      - if last row height < lastRowMaxHeight then use that height (last row will be width-aligned, though a bit higher than other rows)
    //      - otherwise use rowMaxHeight for the last row (last row won't be width-aligned)
    rowMaxHeight = rowMaxHeight || [160];
    rowMinHeight = rowMinHeight || 100;
    let allow2ndPass = pendingLoadCount === 0;

    if (!Array.isArray(rowMaxHeight)) {
      rowMaxHeight = [rowMaxHeight];
    }

    let itemIndex = 0;
    let rowIndex = -1;
    let out = [];

    while (itemIndex < data.length) {
      rowIndex++;
      let maxHeight = rowMaxHeight[rowIndex % rowMaxHeight.length];
      let row = this._computeTrackRow(data, rowMinHeight, maxHeight, rowIndex, width, itemIndex);
      let height = row[0].height;
      if (height <= maxHeight || itemIndex + row.length < data.length) {
        itemIndex += row.length;
        out.push(row);
        continue;
      }

      // last row is not fully aligned (it is too narrow)
      // => perform 2nd pass backwards trying to distribute images from last row
      // to previous ones so that the last row is fully aligned too
      let height1stPass = height;
      let n1stPass = itemIndex;
      let out1stPass = [...out];
      let pending = data.slice(itemIndex);
      if (allow2ndPass) {
        for (let i = out.length - 1; i >= 0 && pending.length > 0; i--) {
          let rowLength = out[i].length;
          itemIndex -= rowLength;
          let test = data.slice(itemIndex, itemIndex + rowLength).concat(pending);
          let height;
          pending = [];
          while ((height = this._getRowItems(test, width)) < rowMinHeight) {
            pending.push(test.shift());
            if (test.length <= 1) break;
          }
          out[i] = this._setHeight(test, i, height, width);
        }
      }
      if (pending.length) {
        // it didn't work out => use the solution with narrow last row but try to widen it
        // yet without crossing lastRowMaxHeight height (and fall back to using narrow last row)
        out = out1stPass;
        let usedLastRowMaxHeight =
          pendingLoadCount > 0 ? maxHeight : typeof lastRowMaxHeight !== "number" ? 1.6 * maxHeight : lastRowMaxHeight;
        let lastRow = this._setHeight(
          data.slice(n1stPass),
          rowIndex,
          height1stPass <= usedLastRowMaxHeight ? height1stPass : maxHeight,
          width
        );
        out.push(lastRow);
      }
      break;
    }

    // if still loading images then force height of the currently last row & add 4:3 placeholder
    // images in the place of not-yet-loaded images
    if (pendingLoadCount > 0 && out.length) {
      let lastRow = out.pop();
      let lastRowMaxHeight = rowMaxHeight[lastRow[0].row % rowMaxHeight.length];

      const PLACEHOLDER_RATIO = [4, 3];
      let extendedData = [...data];
      for (let i = 0; i < pendingLoadCount; i++) {
        extendedData.push({
          height: PLACEHOLDER_RATIO[1] * lastRowMaxHeight,
          width: PLACEHOLDER_RATIO[0] * lastRowMaxHeight,
          placeholder: true
        });
      }
      let rowIndex = lastRow[0].row;
      let itemIndex = data.length - lastRow.length;
      let usedRow;
      let desiredHeight = Math.max(rowMinHeight, Math.floor((rowMinHeight + lastRowMaxHeight) / 2));
      if (lastRow[0].height > desiredHeight) {
        // row is not sufficiently filled => keep it at desiredHeight height and adapt last placeholder
        // in the row
        let filledWidth = 0;
        let i;
        for (i = itemIndex; i < extendedData.length; i++) {
          let item = extendedData[i];
          filledWidth += (item.width * desiredHeight) / item.height;
          if (i > itemIndex) filledWidth += this.getDefault().padding * 2;
          let remainingSingleItemSpace = width - filledWidth - this.getDefault().padding * 2;
          if (i >= data.length - 1) {
            if (PLACEHOLDER_RATIO[1] * remainingSingleItemSpace < 1 * desiredHeight) {
              break;
            } else if (
              PLACEHOLDER_RATIO[1] * remainingSingleItemSpace < (PLACEHOLDER_RATIO[0] + 1) * desiredHeight &&
              i < extendedData.length - 1
            ) {
              // remaining ratio is >= 1/3 && ratio < 5/3 => enlarge the last placed item (if it is placeholder)
              usedRow = this._setHeight(extendedData.slice(itemIndex, i + 2), rowIndex, desiredHeight, width);
              usedRow[usedRow.length - 1].width = remainingSingleItemSpace;
              break;
            }
          }
        }
      } else {
        usedRow = lastRow;
      }
      if (usedRow) {
        itemIndex += usedRow.length;
        rowIndex++;
        out.push(usedRow);
      }
      // add remaining rows (all filled only with placeholders)
      while (itemIndex < extendedData.length) {
        let maxHeight = rowMaxHeight[rowIndex % rowMaxHeight.length];
        let row = this._computeTrackRow(extendedData, rowMinHeight, maxHeight, rowIndex, width, itemIndex);
        if (row[0].height > maxHeight && itemIndex + row.length >= extendedData.length) {
          // last row is big => keep it at average height (will not be width-aligned with previous rows)
          let finalRowPendingHeight = Math.max(rowMinHeight, Math.floor((rowMinHeight + lastRowMaxHeight) / 2));
          row = this._setHeight(extendedData.slice(itemIndex), rowIndex, finalRowPendingHeight, width);
        }
        rowIndex++;
        itemIndex += row.length;
        out.push(row);
      }
    }

    return out;
  },

  _computeTrackRow(data, rowMinHeight, rowMaxHeight, rowIndex, width, dataIndexFrom = 0) {
    let result;
    let height = data[dataIndexFrom].height;
    let previousHeight = 0;
    for (let i = dataIndexFrom; i < data.length; i++) {
      let test = data.slice(dataIndexFrom, i + 1);
      previousHeight = height;
      height = this._getRowItems(test, width);
      if (height <= rowMaxHeight) {
        if (height < rowMinHeight && i > dataIndexFrom) {
          test = data.slice(dataIndexFrom, i); //i-1
          height = previousHeight;
        }
        result = this._setHeight(test, rowIndex, height, width);
        break;
      }
    }
    if (!result) result = this._setHeight(data.slice(dataIndexFrom), rowIndex, height, width);
    return result;
  },

  _getChildrenDefault() {
    return (
      <UU5.Bricks.Row>
        {this.state.imgList.map((photo, i) => {
          let colWidth = this.props.colWidth && this.props.colWidth.trim();
          return (
            <UU5.Bricks.Column colWidth={colWidth} key={i}>
              <Image
                src={photo.lightboxSrc}
                thumb={photo.thumb}
                alt={photo.alt}
                caption={photo.caption}
                effect={this.props.effect}
                shape={this.props.shape}
                lightbox={this._getLightbox()}
                authenticate={this.props.authenticate}
              />
            </UU5.Bricks.Column>
          );
        })}
      </UU5.Bricks.Row>
    );
  },

  _getChildren() {
    let children;

    switch (this.props.mode) {
      case "track":
        children = this._getChildrenTrack();
        break;
      default:
        children = this._getChildrenDefault();
    }

    return children || null;
  },

  _getChildrenTrack() {
    let width = this.props.rowWidth;
    let rows = this._getTrackGrid(
      this.state.imgList,
      width,
      this.props.rowMaxHeight,
      this.props.rowMinHeight,
      this.props.lastRowMaxHeight,
      this.state.pendingLoadCount
    );
    let result = [];

    for (let i = 0; i < rows.length; i++) {
      for (let j = 0; j < rows[i].length; j++) {
        let photo = rows[i][j];
        result.push(
          <div
            key={i + "-" + j}
            className={
              this.getClassName("mode") +
              this.props.mode +
              (photo.placeholder ? " " + this.getClassName("placeholder") : "")
            }
            style={{
              width: photo.width,
              height: photo.height,
              marginTop: i ? this.getDefault().padding : 0,
              marginBottom: i === rows.length - 1 ? 0 : this.getDefault().padding,
              marginLeft: photo.left,
              marginRight: photo.right
            }}
          >
            <Image
              thumb={photo.thumb}
              src={photo.lightboxSrc}
              alt={photo.alt}
              caption={photo.caption}
              effect={this.props.effect}
              lightbox={this._getLightbox()}
              height={photo.height}
              authenticate={this.props.authenticate}
            />
          </div>
        );
      }
    }

    return result;
  },
  //@@viewOff:private

  //@@viewOn:render
  render() {
    return this._getChildren();
  }
  //@@viewOff:render
});

export default ThumbnailListBody;
