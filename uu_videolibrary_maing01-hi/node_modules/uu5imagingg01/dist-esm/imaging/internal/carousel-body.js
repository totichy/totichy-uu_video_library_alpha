import UU5 from "uu5g04";
import memoize from "memoize-one";
import Cfg from "../../config/config.js";
import Tools from "./tools.js";
import CarouselItem from "./carousel-item.js";
import CarouselContext from "./carousel-context.js";

const carouselProps = {
  hideControls: true,
  hideIndicators: true,
  activeIndex: true,
  nextIcon: true,
  prevIcon: true,
  displayedItems: true,
  type: true,
  interval: true,
  stepByOne: true,
  ref_: true
};

export const CarouselBody = UU5.Common.VisualComponent.create({
  //@@viewOn:mixins
  mixins: [UU5.Common.BaseMixin],
  //@@viewOff:mixins

  //@@viewOn:statics
  statics: {
    tagName: Cfg.TAG + "CarouselBody",
    classNames: {
      main: props =>
        Cfg.CSS +
        "carousel-body " +
        UU5.Common.Css.css`
        && {
          text-align: center;
          width: ${UU5.Common.Tools.fillUnit(props.width)};
        }
    `,
      carouselItem: props => UU5.Common.Css.css`
      display: flex;
      align-items: center;
      justify-content: center;
      height: ${UU5.Common.Tools.fillUnit(props.height)};
    `,
      image: props => UU5.Common.Css.css`
        && {
          & > .uu5-bricks-link {
            display: inline-block;
          }

          img.uu5-bricks-image {
            height: ${props.fit === "contain" ? UU5.Common.Tools.fillUnit(props.height) : "100%"};
            width: ${props.fit === "contain" ? "auto" : "100%"};
            max-width: 100%;
            object-fit: ${props.fit};
          }

          &:focus .uu5-imaging-image-focus-wrapper {
            box-shadow: none;
          }
        }

      `,
      errorImage: UU5.Common.Css.css`
        &&& img.uu5-bricks-image {
          height: auto;
        }
      `
    },
    opt: {
      hoc: true
    },
    imageCache: {}
  },
  //@@viewOff:statics

  //@@viewOn:propTypes
  propTypes: {
    data: UU5.PropTypes.arrayOf(
      UU5.PropTypes.oneOfType([
        UU5.PropTypes.string,
        UU5.PropTypes.shape({
          src: UU5.PropTypes.string.isRequired
        })
      ])
    ).isRequired,
    authenticate: UU5.PropTypes.bool,
    session: UU5.PropTypes.object,
    width: UU5.PropTypes.oneOfType([UU5.PropTypes.number, UU5.PropTypes.string]),
    height: UU5.PropTypes.number,
    hideControls: UU5.PropTypes.bool,
    hideIndicators: UU5.PropTypes.bool,
    activeIndex: UU5.PropTypes.number,
    nextIcon: UU5.PropTypes.string,
    prevIcon: UU5.PropTypes.string,
    displayedItems: UU5.PropTypes.number,
    type: UU5.PropTypes.oneOf(["circular", "final", "rewind"]),
    interval: UU5.PropTypes.number,
    stepByOne: UU5.PropTypes.bool,
    fit: UU5.PropTypes.oneOf(["cover", "contain"])
  },
  //@@viewOff:propTypes

  //@@viewOn:getDefaultProps
  getDefaultProps() {
    return {
      data: null,
      session: undefined,
      authenticate: false,
      width: null,
      height: 500,
      hideControls: false,
      hideIndicators: false,
      activeIndex: 0,
      nextIcon: "mdi-chevron-right",
      prevIcon: "mdi-chevron-left",
      displayedItems: 1,
      type: "final",
      interval: 5000,
      stepByOne: false,
      fit: "cover"
    };
  },
  //@@viewOff:getDefaultProps

  //@@viewOn:reactLifeCycle
  getInitialState() {
    this._renderImages = memoize(this._renderImages);

    return {
      imgList: [],
      activeIndex: this.props.activeIndex
    };
  },

  componentDidMount() {
    this._loadedIndexes = [];
    // make sure to always render the same instance of children. This is needed due to UU5.Bricks.Carousel
    // having a componentDidUpdate logic which, when receivening any new props (prevProps !== this.props),
    // re-renders the component without triggering the transition animations.
    this._loadImages();
  },

  componentWillReceiveProps(nextProps) {
    if (
      !UU5.Common.Tools.deepEqual(this.props.data, nextProps.data) ||
      nextProps.activeIndex !== this.props.activeIndex ||
      nextProps.displayedItems !== this.props.displayedItems ||
      nextProps.stepByOne !== this.props.stepByOne ||
      nextProps.type !== this.props.type
    ) {
      this._loadedIndexes = [];
      if (nextProps.data.length) {
        this._loadImages(nextProps);
      } else {
        this.setState({ imgList: [] });
      }
    }
  },
  //@@viewOff:reactLifeCycle

  //@@viewOn:interface
  //@@viewOff:interface

  //@@viewOn:overridingMethods
  //@@viewOff:overridingMethods

  //@@viewOn:private
  async _loadImages(props = this.props, activeIndex, setStateCallback) {
    if (this._loadedIndexes.length < props.data.length) {
      // else all images have already been loaded and cached
      activeIndex = typeof activeIndex === "number" ? activeIndex : props.activeIndex;

      if (!props.stepByOne) {
        activeIndex = activeIndex * props.displayedItems;
      }

      this._dataChangeId = Math.random();
      let imgList = props.data.map(() => null);
      let dataChangeId = this._dataChangeId;
      let preloadNumber = props.displayedItems === 1 || props.stepByOne ? 1 : props.displayedItems;

      // load previous items
      [...new Array(preloadNumber)].reverse().forEach((_, index) => {
        let newIndex = activeIndex - (index + 1);

        if (this._loadedIndexes.indexOf(newIndex) === -1) {
          this._loadedIndexes.push(newIndex);
        }
      });

      // load visible items
      [...new Array(props.displayedItems)].forEach((_, index) => {
        let newIndex = activeIndex + index;

        if (this._loadedIndexes.indexOf(newIndex) === -1) {
          this._loadedIndexes.push(newIndex);
        }
      });

      // load next items
      [...new Array(preloadNumber)].forEach((_, index) => {
        let newIndex = activeIndex + props.displayedItems - 1 + (index + 1);

        if (this._loadedIndexes.indexOf(newIndex) === -1) {
          this._loadedIndexes.push(newIndex);
        }
      });

      // adjust items (over the limit or below)
      this._loadedIndexes.forEach((index, i) => {
        let isBelow = index < 0;
        let isAbove = index > imgList.length - 1;

        if (props.type === "final" && (isBelow || isAbove)) {
          this._loadedIndexes[i] = null;
        } else {
          if (isBelow) {
            this._loadedIndexes[i] = imgList.length + index;
          } else if (isAbove) {
            this._loadedIndexes[i] = index - imgList.length;
          }
        }
      });

      if (props.type !== "circular" && activeIndex + preloadNumber > imgList.length) {
        [...new Array(imgList.length - activeIndex + preloadNumber)].forEach((_, index) => {
          let newIndex = activeIndex - (index + 1);

          if (this._loadedIndexes.indexOf(newIndex) === -1) {
            this._loadedIndexes.push(newIndex);
          }
        });
      }

      this._loadedIndexes = this._loadedIndexes.filter(index => index !== null);

      for (let i = 0; i < this._loadedIndexes.length; i++) {
        let imageIndex = this._loadedIndexes[i];

        if (typeof imageIndex === "number") {
          const image = await this._loadImage(props.data[imageIndex], props.authenticate, props.session);

          if (dataChangeId !== this._dataChangeId) return;

          if (image) {
            imgList[imageIndex] = image;
          }
        }
      }

      let newState = { imgList };

      if (typeof activeIndex === "number") {
        newState.activeIndex = activeIndex;
      }

      this.setAsyncState(newState, setStateCallback);
    }
  },

  _loadImage(item, authenticate, session) {
    if (typeof item === "string") {
      item = { src: item };
    }

    let src = item.src;
    let cacheMatch = this.constructor.imageCache[src];
    let result;

    if (cacheMatch) {
      result = cacheMatch;
    } else {
      if (authenticate) {
        session = session || UU5.Environment.getSession();
        if (session && session.isAuthenticated() && UU5.Environment.isTrustedDomain(src)) {
          result = new Promise(resolve => {
            let usedItem = { ...item };
            Tools.fetchAuthenticatedImage(src, session).then(
              data => {
                usedItem.src = URL.createObjectURL(data.data);
                resolve(this._getImageData(usedItem, src));
              },
              err => {
                usedItem.src = "data:image/gif;base64,ZZZZZZZZ"; // invalid image
                resolve(this._getImageData(usedItem, src));
              }
            );
          });
        }
      }
    }

    if (!result) {
      result = this._getImageData(item, src);
    }

    return result;
  },

  _getImageData(item, cacheKey) {
    return new Promise(resolve => {
      let src;

      if (item && typeof item === "object") {
        src = item.src;
      } else {
        src = item;
      }

      let img = new window.Image();

      img.onload = () => {
        let imgObj = {
          src,
          width: img.width,
          height: img.height,
          alt: img.alt || "",
          error: false
        };

        this.constructor.imageCache[cacheKey] = imgObj;

        resolve(imgObj);
      };

      img.onerror = () => {
        let imgObj = {
          src: "data:image/gif;base64,ZZZZZZZZ",
          alt: img.alt || "",
          error: true
        };
        resolve(imgObj);
      };

      img.alt = item.alt || "";
      img.src = src;
    });
  },

  _onIndexChange({ activeIndex }) {
    this._loadImages(this.props, activeIndex);
  },

  _getImageProps(itemId) {
    let data = this.state.imgList[itemId];

    if (data) {
      let className = this.getClassName("image");
      if (data.error) {
        className += " " + this.getClassName("errorImage");
      }

      return {
        src: data.src,
        caption: data.caption,
        alt: data.alt,
        lightbox: false,
        authenticate: this.props.authenticate,
        width: this.props.fit === "contain" ? "auto" : "100%",
        height: this.props.fit === "contain" ? "auto" : "100%",
        className
      };
    } else {
      return null;
    }
  },

  _renderImages(imgListLength) {
    return [...new Array(imgListLength)].map((_, index) => (
      <UU5.Bricks.Carousel.Item key={index} className={this.getClassName("carouselItem")}>
        <CarouselItem id={index + ""} />
      </UU5.Bricks.Carousel.Item>
    ));
  },
  //@@viewOff:private

  //@@viewOn:render
  render() {
    let props = {};

    for (let propKey in carouselProps) {
      props[propKey] = this.props[propKey];
    }

    return (
      <CarouselContext.Provider value={{ getImageProps: this._getImageProps }}>
        <UU5.Bricks.Carousel
          {...this.getMainPropsToPass()}
          {...props}
          displayedItems={props.displayedItems || 1}
          onIndexChange={this._onIndexChange}
        >
          {this._renderImages(this.state.imgList.length)}
        </UU5.Bricks.Carousel>
      </CarouselContext.Provider>
    );
  }
  //@@viewOff:render
});

export default CarouselBody;
