import * as UU5 from "uu5g04";
import "uu5imagingg01";

export const adjustFile = (data, { outputQuality, outputMaxWidth, outputMaxHeight } = {}) => {
  return new Promise((resolve, reject) => {
    // we adjust only images and adjustment must be set via props
    // so if file is not an image or is not set any of props changing output quality
    if (!isImage(data) || (!outputQuality && !outputMaxHeight && !outputMaxWidth)) {
      return resolve(data);
    }

    // handle output quality
    new Promise(resolveOutputQuality => {
      if (outputQuality) {
        UU5.Imaging.Adjustment.changeType(data, "jpg", outputQuality).then(resultOutputQuality =>
          resolveOutputQuality(resultOutputQuality.imageFile)
        );
      } else {
        // no output quality change is needed
        resolveOutputQuality(data);
      }
    }).then(imageFile => {
      // handle resize of a image if is needed
      if (outputMaxWidth || outputMaxHeight) {
        UU5.Imaging.Adjustment.resizeMax(imageFile, outputMaxWidth, outputMaxHeight).then(
          resultResizeMax => {
            resolve(resultResizeMax.imageFile);
          },
          resultResizeMaxError => {
            reject({ error: Object.assign(resultResizeMaxError, { code: "resizeFailed" }) });
          }
        );
      } else {
        // no resize is needed
        resolve(imageFile);
      }
    });
  });
};

const MAX_SIZE = 128 * 1024;

export const getMaxFileSize = sizeLimit => {
  return sizeLimit ? Math.min(MAX_SIZE, sizeLimit) : MAX_SIZE;
};

export function isImage(file) {
  return file && file.type && !!file.type.match(/image\//);
}

export function getBinaryData(binary) {
  let type;
  let icon;
  let thumbnail = "icon";
  let clickable = false;

  const binaryType = binary.contentType;
  const binaryName = binary.filename;

  if (binaryType.match(/\/svg/)) {
    type = "svg";
    icon = "mdi-file-image";
    thumbnail = "original";
    clickable = true;
  } else if (binaryType.match(/image\//)) {
    type = "image";
    icon = "mdi-file-image";
    thumbnail = "thumbnail";
    clickable = true;
  } else if (binaryType.match(/\/pdf/)) {
    type = "pdf";
    icon = "mdi-file-pdf";
    clickable = true;
  } else if (binaryType.match(/(\/html)|(\/xml)/)) {
    type = "xml";
    icon = "mdi-file-xml";
  } else if (binaryType.match(/(\/text$)|(^text\/)/)) {
    type = "text";
    icon = "mdi-file-document";
  } else if (binaryType.match(/\/json/)) {
    type = "json";
    icon = "mdi-json";
  } else if (binaryName && binaryName.match(/(\.rar$)|(\.zip$)|(\.7z$)|(\.tgz$)|(\.tar$)|(\.tar\.gz$)/)) {
    type = "archive";
    icon = "mdi-package";
  } else {
    type = "other";
    icon = "mdi-file";
  }

  return {
    type: type,
    icon: icon,
    thumbnail: thumbnail,
    clickable: clickable
  };
}

export function createObjectURL(file) {
  let result;
  try {
    result = URL.createObjectURL(file);
  } catch (err) {
    result = undefined;
  }
  return result;
}

export function getImageElement(imageFile) {
  return new Promise((resolve, reject) => {
    let image = new Image();
    image.src = createObjectURL(imageFile);
    image.onload = () => {
      resolve(image);
    };
    image.onerror = () => {
      reject(new Error("Image failed to load in <img> element."));
    };
  });
}

export default { adjustFile, getMaxFileSize, isImage, getBinaryData, createObjectURL, getImageElement };
