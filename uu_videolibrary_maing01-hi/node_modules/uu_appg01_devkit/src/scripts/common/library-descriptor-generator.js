const path = require("path");
const fs = require("fs");
const Package = require("uu_appg01_devkit-common/src/tools/package.js");
const { getCdnName } = require("../common/dependency-processor.js");

const DEFAULT_GATEWAY_URI = "https://cdn.plus4u.net";
const SCHEMA_VERSION = "1.0.0";

class LibraryDescriptorGenerator {
  constructor(
    projectRoot,
    projectName,
    projectVersion,
    targetDir,
    buildConfig,
    dependencies,
    loaderSettings,
    projectType,
    isPartOfMultiLib
  ) {
    this.projectRoot = projectRoot;
    this.projectName = projectName;
    this.projectVersion = projectVersion;
    this.projectType = projectType;
    this.targetDir = targetDir;
    this.dependencies = dependencies || {};
    this.loaderSettings = loaderSettings || {};
    this.buildConfig = buildConfig;
    this.isPartOfMultiLib = isPartOfMultiLib;
  }

  static transformLegacyDescriptor(legacyDescriptor, type, flsUri, license) {
    if (!legacyDescriptor) return legacyDescriptor;
    let list = Array.isArray(legacyDescriptor) ? legacyDescriptor : [legacyDescriptor];
    let version = list[0].versionList && list[0].versionList[0] && list[0].versionList[0].version;
    let generation = parseFloat((list[0].name.match(/g(\d\d)/) || {})[1]) || 0;
    let uuApp =
      (list[0].name.startsWith(list[0].vendor + "_") ? "" : list[0].vendor + "_") + list[0].name.replace(/g\d\d.*/, "");
    let libraryList = list.map((it) => ({
      code: it.code,
      name: it.name,
      type,
      license,
      desc: it.desc,
      docUri: it.doc,
      imageUri: it.image,
      flsUri,
      sourceUri: it.source ? it.source.replace(/%s/, () => version) : it.source,
      dependencyMap: (it.versionList && it.versionList[0] && it.versionList[0].dependencyMap) || it.dependencyMap,
    }));
    let descriptor = {
      schemaVersion: SCHEMA_VERSION,
      version,
      generation,
      uuApp,
      libraryList,
    };
    return descriptor;
  }

  generateLibraryDescriptor(customLibraryDescriptor = null) {
    let descriptorPath = path.resolve(
      this.targetDir,
      `${this.projectName}-${this.projectVersion}-library-descriptor.json`
    );
    descriptorPath = path.relative(".", descriptorPath);

    let libraryDescriptor = customLibraryDescriptor;
    if (!libraryDescriptor) {
      let parsedProduct = Package.parseProduct(this.projectName);
      let { sourceUri, imageUri, docUri, namespace, description, componentList, license } = this.buildConfig.getAll();
      let isForCdn = this.projectType !== "nodejs-lib";
      let version = this.projectVersion;
      libraryDescriptor = {
        schemaVersion: SCHEMA_VERSION,
        version,
        generation: parseFloat((this.projectName.match(/g(\d\d)/) || {})[1]) || 0,
        uuApp:
          (parsedProduct.name.startsWith(parsedProduct.vendor + "_") ? "" : parsedProduct.vendor + "_") +
          parsedProduct.name.replace(/g\d\d.*/, ""),
        libraryList: [
          {
            code: namespace,
            name: parsedProduct.name,
            type: this.projectType,
            license,
            desc: description,
            docUri,
            imageUri,
            flsUri: this.buildConfig.get("flsUri"),
            ...(isForCdn
              ? {
                  sourceUri: sourceUri ? sourceUri.replace(/%s/, () => version) : sourceUri,
                  dependencyMap: Object.keys(this.loaderSettings.externals || {}).reduce((depMap, depName) => {
                    let depItem = this.loaderSettings.externals[depName];
                    if (depItem && depItem.uri !== undefined) {
                      depMap[depName] = depItem.uri;
                    }
                    return depMap;
                  }, {}),
                }
              : null),
          },
        ],
        componentList: !componentList
          ? undefined
          : componentList.map((it) => {
              let { docCode, tagList, code, ...result } = it;
              if (code) result.code = code;
              if (tagList || code) result.tagList = tagList || code.split(/\./);
              if (docCode && docUri) {
                let url = new URL(docUri);
                url.searchParams.set("code", docCode);
                if (url.pathname.match(/\/book\/?$/)) url.pathname = url.pathname.replace(/(\/book)\/?$/, "$1/page");
                result.docUri = url.toString();
              }
              if (!result.libraryCode) result.libraryCode = namespace;
              return result;
            }),
      };
      if (isForCdn) this._updateLibraryRegistryDescriptor(libraryDescriptor, descriptorPath);

      if (!this.projectVersion.match(/[-.][a-zA-Z]/)) {
        let requiredFields = ["flsUri", "docUri", "imageUri"].concat(isForCdn ? ["sourceUri"] : []);
        let emptyFields = requiredFields.filter((it) => !libraryDescriptor.libraryList[0][it]);
        if (emptyFields.length > 0) {
          let keyPrefix = this.isPartOfMultiLib ? "" : path.basename(path.resolve(".")) + ".";
          throw new Error(
            `Missing uuapp.json keys: ${emptyFields
              .map((it) => keyPrefix + it)
              .join(", ")} (required for non-beta versions).`
          );
        }
      }
    }

    fs.writeFileSync(descriptorPath, JSON.stringify(libraryDescriptor, null, 2));
    return { descriptor: libraryDescriptor, descriptorPath };
  }

  _getDependencyInfo(name) {
    let depPackageJsonPath = path.join(this.projectRoot, "node_modules", name, "package.json");
    let isThisProject = false;
    let version;
    if (fs.existsSync(depPackageJsonPath)) {
      let depPackageJson = JSON.parse(fs.readFileSync(depPackageJsonPath, "utf-8"));
      version = depPackageJson.version;
    } else if (name === this.projectName || name.startsWith(this.projectName + "-")) {
      version = this.projectVersion;
      isThisProject = true;
    }
    return { name, version, isThisProject };
  }

  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  _updateLibraryRegistryDescriptor(descriptor, descriptorPath) {
    // TODO Integrate method directly into generateLibraryDescriptor()
    // update versions and URLs of library registry items (copied from uu5g04)
    let knownDeps = {
      [this.projectName]: {
        name: this.projectName,
        version: this.projectVersion,
        external: true,
        isThisProject: true,
      },
    };
    let loaderSettingsDeps = this.loaderSettings.externals || {};
    for (let depName in this.dependencies) {
      let { isThisProject, version } = this._getDependencyInfo(depName);
      knownDeps[depName] = {
        name: depName,
        version,
        external: depName in loaderSettingsDeps,
        isThisProject,
      };
    }

    descriptor.libraryList.forEach((lib) => {
      // update URLs in dependencyMap
      updateDependencyMap.call(this, lib.dependencyMap, lib);
    });

    function updateDependencyMap(dependencyMap, lib) {
      if (dependencyMap) {
        for (let depLibFullName in dependencyMap) {
          let depLibUrl = dependencyMap[depLibFullName];
          if (!depLibUrl) {
            let depLibNameBase = depLibFullName.split("-")[0];
            let depLibParams = knownDeps[depLibFullName] || knownDeps[depLibNameBase];

            if (depLibParams) {
              if (!depLibParams.external) {
                throw new Error(
                  `Library ${depLibFullName} is declared as dependency for ${lib.name} in ${descriptorPath}` +
                    `but it's not marked as external dependency (listed in package.json in "uuBuildSettings.externals"),` +
                    ` i.e. it was bundled into the distribution package if it was imported somewhere in source files. Mark` +
                    ` it as external in package.json or remove it from library registry descriptor.`
                );
              }
              let cdnLibName = getCdnName(depLibFullName, true);
              let isBeta = (depLibParams.version || "").match(/[-.][a-zA-Z]/);
              // we want to use major versions in registry so that there're fewest version conflicts
              // (but not for submodules such as -bricks, etc. of this library, if this library has some)
              let depLibUsedVersion = depLibParams.version || "0.0.0";
              if (!depLibParams.isThisProject) depLibUsedVersion = depLibUsedVersion.replace(/\..*/, ".0.0");
              let fileName = depLibFullName.replace(/^uu_uu5/, "uu5") + ".min.js";
              if (depLibFullName === "uu_appg01" && depLibUsedVersion.match(/^[0123]\./))
                fileName = "uu_appg01-base.min.js"; // uu_appg01 < 4.x had non-standard naming of entry file
              depLibUrl = `${DEFAULT_GATEWAY_URI}/${
                isBeta ? "beta/" : ""
              }${cdnLibName}/${depLibUsedVersion}/${fileName}`;
              if (!depLibParams.version) {
                console.warn(
                  `Library ${depLibFullName} is declared as external dependency (listed in package.json in "uuBuildSettings.externals")` +
                    `, it has no URL specified there and it's not possible to find out its version. Following URL will be used for library` +
                    ` registry:\n  ${depLibUrl}\n If the URL is wrong, specify the URL in package.json in "uuBuildSettings.externals.` +
                    `${depLibFullName}.uri" or add the library as npm dependency (npm i -S ${depLibFullName}).`
                );
              }
              dependencyMap[depLibFullName] = depLibUrl;
            } else {
              throw new Error(
                `Library ${depLibFullName} is declared as external dependency (listed in package.json in "uuBuildSettings.externals")` +
                  ` but it has no URL specified there. Specify the URL in package.json in "uuBuildSettings.externals.${depLibFullName}.uri"` +
                  ` or add the library as npm dependency (npm i -S ${depLibFullName}) to compute the URL automatically (assuming the` +
                  ` library conforms to standard UU naming conventions).`
              );
            }
          }
        }
      }
      return dependencyMap;
    }
  }
}

module.exports = LibraryDescriptorGenerator;
